import { createStorefrontClient as createStorefrontClient$1, StorefrontClientProps, ShopPayButton as ShopPayButton$1 } from '@shopify/hydrogen-react';
export { AnalyticsEventName, AnalyticsPageType, ClientBrowserParameters, ExternalVideo, IMAGE_FRAGMENT, Image, MediaFile, ModelViewer, Money, ParsedMetafields, ShopifyAddToCart, ShopifyAddToCartPayload, ShopifyAnalytics, ShopifyAnalyticsPayload, ShopifyAnalyticsProduct, ShopifyCookies, ShopifyPageView, ShopifyPageViewPayload, ShopifySalesChannel, StorefrontApiResponse, StorefrontApiResponseError, StorefrontApiResponseOk, StorefrontApiResponseOkPartial, StorefrontApiResponsePartial, Video, flattenConnection, getClientBrowserParameters, getShopifyCookies, parseGid, parseMetafield, sendShopifyAnalytics, storefrontApiCustomScalars, useLoadScript, useMoney, useShopifyCookies } from '@shopify/hydrogen-react';
import { ExecutionArgs } from 'graphql';
import { LanguageCode, CountryCode, Maybe, PageInfo, CartMetafieldsSetInput, Cart, CartUserError, MetafieldsSetUserError, MetafieldDeleteUserError, Scalars, AttributeInput, CartBuyerIdentityInput, CartInput, CartLineInput, CartLineUpdateInput, CartSelectedDeliveryOptionInput, ProductOption, ProductVariantConnection, ProductVariant, SelectedOptionInput } from '@shopify/hydrogen-react/storefront-api-types';
import { LoaderFunctionArgs, LoaderFunction, SerializeFrom } from '@remix-run/server-runtime';
import * as react from 'react';
import { ReactNode, Ref, ComponentType, ComponentProps } from 'react';
import { Params, Location, LinkProps, FetcherWithComponents } from '@remix-run/react';
import { Thing, WithContext } from 'schema-dts';
import { PartialDeep } from 'type-fest';
import * as react_jsx_runtime from 'react/jsx-runtime';

/**
 * Override options for a cache strategy.
 */
interface AllCacheOptions {
    /**
     * The caching mode, generally `public`, `private`, or `no-store`.
     */
    mode?: string;
    /**
     * The maximum amount of time in seconds that a resource will be considered fresh. See `max-age` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#:~:text=Response%20Directives-,max%2Dage,-The%20max%2Dage).
     */
    maxAge?: number;
    /**
     * Indicate that the cache should serve the stale response in the background while revalidating the cache. See `stale-while-revalidate` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-while-revalidate).
     */
    staleWhileRevalidate?: number;
    /**
     * Similar to `maxAge` but specific to shared caches. See `s-maxage` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#s-maxage).
     */
    sMaxAge?: number;
    /**
     * Indicate that the cache should serve the stale response if an error occurs while revalidating the cache. See `stale-if-error` in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#stale-if-error).
     */
    staleIfError?: number;
}
/**
 * Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the pre-defined caching strategies: CacheNone, CacheShort, CacheLong.
 */
type CachingStrategy = AllCacheOptions;
type NoStoreStrategy = {
    mode: string;
};
declare function generateCacheControlHeader(cacheOptions: CachingStrategy): string;
/**
 *
 * @public
 */
declare function CacheNone(): NoStoreStrategy;
/**
 *
 * @public
 */
declare function CacheShort(overrideOptions?: CachingStrategy): AllCacheOptions;
/**
 *
 * @public
 */
declare function CacheLong(overrideOptions?: CachingStrategy): AllCacheOptions;
/**
 *
 * @public
 */
declare function CacheCustom(overrideOptions: CachingStrategy): AllCacheOptions;

type I18nBase = {
    language: LanguageCode;
    country: CountryCode;
};
/**
 * Wraps all the returned utilities from `createStorefrontClient`.
 */
type StorefrontClient<TI18n extends I18nBase> = {
    storefront: Storefront<TI18n>;
};
/**
 * Maps all the queries found in the project to variables and return types.
 */
interface StorefrontQueries {
}
/**
 * Maps all the mutations found in the project to variables and return types.
 */
interface StorefrontMutations {
}
type GenericVariables = ExecutionArgs['variableValues'];
type EmptyVariables = {
    [key: string]: never;
};
type AutoAddedVariableNames = 'country' | 'language';
type IsOptionalVariables<OperationTypeValue extends {
    variables: any;
}> = Omit<OperationTypeValue['variables'], AutoAddedVariableNames> extends EmptyVariables ? true : GenericVariables extends OperationTypeValue['variables'] ? true : false;
type StorefrontCommonOptions<Variables extends GenericVariables> = {
    headers?: HeadersInit;
    storefrontApiVersion?: string;
} & (IsOptionalVariables<{
    variables: Variables;
}> extends true ? {
    variables?: Variables;
} : {
    variables: Variables;
});
type StorefrontQuerySecondParam<RawGqlString extends keyof StorefrontQueries | string = string> = (RawGqlString extends keyof StorefrontQueries ? StorefrontCommonOptions<StorefrontQueries[RawGqlString]['variables']> : StorefrontCommonOptions<GenericVariables>) & {
    cache?: CachingStrategy;
};
type StorefrontMutateSecondParam<RawGqlString extends keyof StorefrontMutations | string = string> = RawGqlString extends keyof StorefrontMutations ? StorefrontCommonOptions<StorefrontMutations[RawGqlString]['variables']> : StorefrontCommonOptions<GenericVariables>;
/**
 * Interface to interact with the Storefront API.
 */
type Storefront<TI18n extends I18nBase = I18nBase> = {
    /** The function to run a query on Storefront API. */
    query: <OverrideReturnType = any, RawGqlString extends string = string>(query: RawGqlString, ...options: RawGqlString extends keyof StorefrontQueries ? IsOptionalVariables<StorefrontQueries[RawGqlString]> extends true ? [StorefrontQuerySecondParam<RawGqlString>?] : [StorefrontQuerySecondParam<RawGqlString>] : [StorefrontQuerySecondParam?]) => Promise<RawGqlString extends keyof StorefrontQueries ? StorefrontQueries[RawGqlString]['return'] : OverrideReturnType>;
    /** The function to run a mutation on Storefront API. */
    mutate: <OverrideReturnType = any, RawGqlString extends string = string>(mutation: RawGqlString, ...options: RawGqlString extends keyof StorefrontMutations ? IsOptionalVariables<StorefrontMutations[RawGqlString]> extends true ? [StorefrontMutateSecondParam<RawGqlString>?] : [StorefrontMutateSecondParam<RawGqlString>] : [StorefrontMutateSecondParam?]) => Promise<RawGqlString extends keyof StorefrontMutations ? StorefrontMutations[RawGqlString]['return'] : OverrideReturnType>;
    /** The cache instance passed in from the `createStorefrontClient` argument. */
    cache?: Cache;
    /** Re-export of [`CacheNone`](/docs/api/hydrogen/2023-10/utilities/cachenone). */
    CacheNone: typeof CacheNone;
    /** Re-export of [`CacheLong`](/docs/api/hydrogen/2023-10/utilities/cachelong). */
    CacheLong: typeof CacheLong;
    /** Re-export of [`CacheShort`](/docs/api/hydrogen/2023-10/utilities/cacheshort). */
    CacheShort: typeof CacheShort;
    /** Re-export of [`CacheCustom`](/docs/api/hydrogen/2023-10/utilities/cachecustom). */
    CacheCustom: typeof CacheCustom;
    /** Re-export of [`generateCacheControlHeader`](/docs/api/hydrogen/2023-10/utilities/generatecachecontrolheader). */
    generateCacheControlHeader: typeof generateCacheControlHeader;
    /** Returns an object that contains headers that are needed for each query to Storefront API GraphQL endpoint. See [`getPublicTokenHeaders` in Hydrogen React](/docs/api/hydrogen-react/2023-10/utilities/createstorefrontclient#:~:text=%27graphql%27.-,getPublicTokenHeaders,-(props%3F%3A) for more details. */
    getPublicTokenHeaders: ReturnType<typeof createStorefrontClient$1>['getPublicTokenHeaders'];
    /** Returns an object that contains headers that are needed for each query to Storefront API GraphQL endpoint for API calls made from a server. See [`getPrivateTokenHeaders` in  Hydrogen React](/docs/api/hydrogen-react/2023-10/utilities/createstorefrontclient#:~:text=storefrontApiVersion-,getPrivateTokenHeaders,-(props%3F%3A) for more details.*/
    getPrivateTokenHeaders: ReturnType<typeof createStorefrontClient$1>['getPrivateTokenHeaders'];
    /** Creates the fully-qualified URL to your myshopify.com domain. See [`getShopifyDomain` in  Hydrogen React](/docs/api/hydrogen-react/2023-10/utilities/createstorefrontclient#:~:text=StorefrontClientReturn-,getShopifyDomain,-(props%3F%3A) for more details. */
    getShopifyDomain: ReturnType<typeof createStorefrontClient$1>['getShopifyDomain'];
    /** Creates the fully-qualified URL to your store's GraphQL endpoint. See [`getStorefrontApiUrl` in  Hydrogen React](/docs/api/hydrogen-react/2023-10/utilities/createstorefrontclient#:~:text=storeDomain-,getStorefrontApiUrl,-(props%3F%3A) for more details.*/
    getApiUrl: ReturnType<typeof createStorefrontClient$1>['getStorefrontApiUrl'];
    /** Determines if the error is resulted from a Storefront API call. */
    isApiError: (error: any) => boolean;
    /** The `i18n` object passed in from the `createStorefrontClient` argument. */
    i18n: TI18n;
};
type HydrogenClientProps<TI18n> = {
    /** Storefront API headers. If on Oxygen, use `getStorefrontHeaders()` */
    storefrontHeaders?: StorefrontHeaders;
    /** An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) */
    cache?: Cache;
    /** The globally unique identifier for the Shop */
    storefrontId?: string;
    /** The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */
    waitUntil?: ExecutionContext['waitUntil'];
    /** An object containing a country code and language code */
    i18n?: TI18n;
};
type CreateStorefrontClientOptions<TI18n extends I18nBase> = HydrogenClientProps<TI18n> & StorefrontClientProps;
type StorefrontHeaders = {
    /** A unique ID that correlates all sub-requests together. */
    requestGroupId: string | null;
    /** The IP address of the client. */
    buyerIp: string | null;
    /** The cookie header from the client  */
    cookie: string | null;
    /** The purpose header value for debugging */
    purpose: string | null;
};
declare const StorefrontApiError: ErrorConstructor;
declare const isStorefrontApiError: (error: any) => boolean;
/**
 *  This function extends `createStorefrontClient` from [Hydrogen React](/docs/api/hydrogen-react/2023-10/utilities/createstorefrontclient). The additional arguments enable internationalization (i18n), caching, and other features particular to Remix and Oxygen.
 *
 *  Learn more about [data fetching in Hydrogen](/docs/custom-storefronts/hydrogen/data-fetching/fetch-data).
 */
declare function createStorefrontClient<TI18n extends I18nBase>(options: CreateStorefrontClientOptions<TI18n>): StorefrontClient<TI18n>;

/**
 * The cache key is used to uniquely identify a value in the cache.
 */
type CacheKey = string | readonly unknown[];

type CrossRuntimeRequest = {
    url?: string;
    method?: string;
    headers: {
        get?: (key: string) => string | null | undefined;
        [key: string]: any;
    };
};

type CreateWithCacheOptions = {
    /** An instance that implements the [Cache API](https://developer.mozilla.org/en-US/docs/Web/API/Cache) */
    cache: Cache;
    /** The `waitUntil` function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */
    waitUntil: ExecutionContext['waitUntil'];
    /** The `request` object is used to access certain headers for debugging */
    request?: CrossRuntimeRequest;
};
/**
 * Creates a utility function that executes an asynchronous operation
 * like `fetch` and caches the result according to the strategy provided.
 * Use this to call any third-party APIs from loaders or actions.
 * By default, it uses the `CacheShort` strategy.
 *
 */
declare function createWithCache<T = unknown>({ cache, waitUntil, request, }: CreateWithCacheOptions): CreateWithCacheReturn<T>;
/**
 * This is a caching async function. Whatever data is returned from the `actionFn` will be cached according to the strategy provided.
 *
 * Use the `CachingStrategy` to define a custom caching mechanism for your data. Or use one of the built-in caching strategies: `CacheNone`, `CacheShort`, `CacheLong`.
 */
type CreateWithCacheReturn<T> = <U = T>(cacheKey: CacheKey, strategy: CachingStrategy, actionFn: () => U | Promise<U>) => Promise<U>;
type WithCache = ReturnType<typeof createWithCache>;

/**
 * This is a limited implementation of an in-memory cache.
 * It only supports the `cache-control` header.
 * It does NOT support `age` or `expires` headers.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Cache
 */
declare class InMemoryCache implements Cache {
    #private;
    constructor();
    add(request: RequestInfo): Promise<void>;
    addAll(requests: RequestInfo[]): Promise<void>;
    matchAll(request?: RequestInfo, options?: CacheQueryOptions): Promise<readonly Response[]>;
    put(request: Request, response: Response): Promise<void>;
    match(request: Request): Promise<Response | undefined>;
    delete(request: Request): Promise<boolean>;
    keys(request?: Request): Promise<Request[]>;
}

type StorefrontRedirect = {
    /** The [Storefront client](/docs/api/hydrogen/2023-10/utilities/createstorefrontclient) instance */
    storefront: Storefront<I18nBase>;
    /** The [MDN Request](https://developer.mozilla.org/en-US/docs/Web/API/Request) object that was passed to the `server.ts` request handler. */
    request: Request;
    /** The [MDN Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) object created by `handleRequest` */
    response?: Response;
    /** By default the `/admin` route is redirected to the Shopify Admin page for the current storefront. Disable this redirect by passing `true`. */
    noAdminRedirect?: boolean;
};
/**
 * Queries the Storefront API to see if there is any redirect
 * created for the current route and performs it. Otherwise,
 * it returns the response passed in the parameters. Useful for
 * conditionally redirecting after a 404 response.
 *
 * @see {@link https://help.shopify.com/en/manual/online-store/menus-and-links/url-redirect Creating URL redirects in Shopify}
 */
declare function storefrontRedirect(options: StorefrontRedirect): Promise<Response>;

type GraphiQLLoader = (args: LoaderFunctionArgs) => Promise<Response>;
declare const graphiqlLoader: GraphiQLLoader;

interface SeoConfig<Schema extends Thing = Thing> {
    /**
     * The <title> HTML element defines the document's title that is shown in a browser's title bar or a page's tab. It
     * only contains text; tags within the element are ignored.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title
     */
    title?: Maybe<string>;
    /**
     * Generate the title from a template that includes a `%s` placeholder for the title.
     *
     * @example
     * ```js
     * {
     *   title: 'My Page',
     *   titleTemplate: 'My Site - %s',
     * }
     * ```
     */
    titleTemplate?: Maybe<string> | null;
    /**
     * The media associated with the given page (images, videos, etc). If you pass a string, it will be used as the
     * `og:image` meta tag. If you pass an object or an array of objects, that will be used to generate `og:<type of
     * media>` meta tags. The `url` property should be the URL of the media. The `height` and `width` properties are
     * optional and should be the height and width of the media. The `altText` property is optional and should be a
     * description of the media.
     *
     * @example
     * ```js
     * {
     *   media: [
     *     {
     *       url: 'https://example.com/image.jpg',
     *       type: 'image',
     *       height: '400',
     *       width: '400',
     *       altText: 'A custom snowboard with an alpine color pallet.',
     *     }
     *   ]
     * }
     * ```
     *
     */
    media?: Maybe<string> | Partial<SeoMedia> | (Partial<SeoMedia> | Maybe<string>)[];
    /**
     * The description of the page. This is used in the `name="description"` meta tag as well as the `og:description` meta
     * tag.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta
     */
    description?: Maybe<string>;
    /**
     * The canonical URL of the page. This is used to tell search engines which URL is the canonical version of a page.
     * This is useful when you have multiple URLs that point to the same page. The value here will be used in the
     * `rel="canonical"` link tag as well as the `og:url` meta tag.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link
     */
    url?: Maybe<string>;
    /**
     * The handle is used to generate the `twitter:site` and `twitter:creator` meta tags. Include the `@` symbol in the
     * handle.
     *
     * @example
     * ```js
     * {
     *   handle: '@shopify'
     * }
     * ```
     */
    handle?: Maybe<string>;
    /**
     * The `jsonLd` property is used to generate the `application/ld+json` script tag. This is used to provide structured
     * data to search engines. The value should be an object that conforms to the schema.org spec. The `type` property
     * should be the type of schema you are using. The `type` property is required and should be one of the following:
     *
     * - `Product`
     * - `ItemList`
     * - `Organization`
     * - `WebSite`
     * - `WebPage`
     * - `BlogPosting`
     * - `Thing`
     *
     * @example
     * ```js
     * {
     *   jsonLd: {
     *     '@context': 'https://schema.org',
     *     '@type': 'Product',
     *     name: 'My Product',
     *     image: 'https://hydrogen.shop/image.jpg',
     *     description: 'A product that is great',
     *     sku: '12345',
     *     mpn: '12345',
     *     brand: {
     *       '@type': 'Thing',
     *       name: 'My Brand',
     *     },
     *     aggregateRating: {
     *       '@type': 'AggregateRating',
     *       ratingValue: '4.5',
     *       reviewCount: '100',
     *     },
     *     offers: {
     *       '@type': 'Offer',
     *       priceCurrency: 'USD',
     *       price: '100',
     *       priceValidUntil: '2020-11-05',
     *       itemCondition: 'https://schema.org/NewCondition',
     *       availability: 'https://schema.org/InStock',
     *       seller: {
     *         '@type': 'Organization',
     *         name: 'My Brand',
     *       },
     *     },
     *   }
     * }
     * ```
     *
     * @see https://schema.org/docs/schemas.html
     * @see https://developers.google.com/search/docs/guides/intro-structured-data
     * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
     *
     */
    jsonLd?: WithContext<Schema> | WithContext<Schema>[];
    /**
     * The `alternates` property is used to specify the language and geographical targeting when you have multiple
     * versions of the same page in different languages. The `url` property tells search engines about these variations
     * and helps them to serve the correct version to their users.
     *
     * @example
     * ```js
     * {
     *   alternates: [
     *     {
     *       language: 'en-US',
     *       url: 'https://hydrogen.shop/en-us',
     *       default: true,
     *     },
     *     {
     *       language: 'fr-CA',
     *       url: 'https://hydrogen.shop/fr-ca',
     *     },
     *   ]
     * }
     * ```
     *
     * @see https://support.google.com/webmasters/answer/189077?hl=en
     */
    alternates?: LanguageAlternate | LanguageAlternate[];
    /**
     * The `robots` property is used to specify the robots meta tag. This is used to tell search engines which pages
     * should be indexed and which should not.
     *
     * @see https://developers.google.com/search/reference/robots_meta_tag
     */
    robots?: RobotsOptions;
}
/**
 * @see https://developers.google.com/search/docs/crawling-indexing/robots-meta-tag
 */
interface RobotsOptions {
    /**
     * Set the maximum size of an image preview for this page in a search results Can be one of the following:
     *
     * - `none` - No image preview is to be shown.
     * - `standard` - A default image preview may be shown.
     * - `large` - A larger image preview, up to the width of the viewport, may be shown.
     *
     * If no value is specified a default image preview size is used.
     */
    maxImagePreview?: 'none' | 'standard' | 'large';
    /**
     * A number representing the maximum of amount characters to use as a textual snippet for a search result. This value
     * can also be set to one of the following special values:
     *
     * - 0 - No snippet is to be shown. Equivalent to nosnippet.
     * - 1 - The Search engine will choose the snippet length that it believes is most effective to help users discover
     *   your content and direct users to your site
     * - -1 - No limit on the number of characters that can be shown in the snippet.
     */
    maxSnippet?: number;
    /**
     * The maximum number of seconds for videos on this page to show in search results. This value can also be set to one
     * of the following special values:
     *
     * - 0 - A static image may be used with the `maxImagePreview` setting.
     * - 1 - There is no limit to the size of the video preview.
     *
     * This applies to all forms of search results (at Google: web search, Google Images, Google Videos, Discover,
     * Assistant).
     */
    maxVideoPreview?: number;
    /**
     * Do not show a cached link in search results.
     */
    noArchive?: boolean;
    /**
     * Do not follow the links on this page.
     *
     * @see https://developers.google.com/search/docs/advanced/guidelines/qualify-outbound-links
     */
    noFollow?: boolean;
    /**
     * Do not index images on this page.
     */
    noImageIndex?: boolean;
    /**
     * Do not show this page, media, or resource in search results.
     */
    noIndex?: boolean;
    /**
     * Do not show a text snippet or video preview in the search results for this page.
     */
    noSnippet?: boolean;
    /**
     * Do not offer translation of this page in search results.
     */
    noTranslate?: boolean;
    /**
     * Do not show this page in search results after the specified date/time.
     */
    unavailableAfter?: string;
}
interface LanguageAlternate {
    /**
     * Language code for the alternate page. This is used to generate the hreflang meta tag property.
     */
    language: string;
    /**
     * Whether the alternate page is the default page. This will add the `x-default` attribution to the language code.
     */
    default?: boolean;
    /**
     * The url of the alternate page. This is used to generate the hreflang meta tag property.
     */
    url: string;
}
type SeoMedia = {
    /**
     * Used to generate og:<type of media> meta tag
     */
    type: 'image' | 'video' | 'audio';
    /**
     * The url value populates both url and secure_url and is used to infer the og:<type of media>:type meta tag.
     */
    url: Maybe<string> | undefined;
    /**
     * The height in pixels of the media. This is used to generate the og:<type of media>:height meta tag.
     */
    height: Maybe<number> | undefined;
    /**
     * The width in pixels of the media. This is used to generate the og:<type of media>:width meta tag.
     */
    width: Maybe<number> | undefined;
    /**
     * The alt text for the media. This is used to generate the og:<type of media>:alt meta tag.
     */
    altText: Maybe<string> | undefined;
};

interface SeoHandleFunction<Loader extends LoaderFunction | unknown = unknown, StructuredDataSchema extends Thing = Thing> {
    (args: {
        data: Loader extends LoaderFunction ? SerializeFrom<Loader> : unknown;
        id: string;
        params: Params;
        pathname: Location['pathname'];
        search: Location['search'];
        hash: Location['hash'];
        key: string;
    }): Partial<SeoConfig<StructuredDataSchema>>;
}
interface SeoProps {
    /** Enable debug mode that prints SEO properties for route in the console */
    debug?: boolean;
}
declare function Seo({ debug }: SeoProps): react.FunctionComponentElement<{
    children?: react.ReactNode;
}>;

declare global {
    interface Window {
        __hydrogenHydrated?: boolean;
    }
}
type Connection<NodesType> = {
    nodes: Array<NodesType>;
    pageInfo: PageInfo;
} | {
    edges: Array<{
        node: NodesType;
    }>;
    pageInfo: PageInfo;
};
interface PaginationInfo<NodesType> {
    /** The paginated array of nodes. You should map over and render this array. */
    nodes: Array<NodesType>;
    /** The `<NextLink>` is a helper component that makes it easy to navigate to the next page of paginated data. Alternatively you can build your own `<Link>` component: `<Link to={nextPageUrl} state={state} preventScrollReset />` */
    NextLink: (props: Omit<LinkProps, 'to'> & {
        ref?: Ref<HTMLAnchorElement>;
    }) => ReactNode;
    /** The `<PreviousLink>` is a helper component that makes it easy to navigate to the previous page of paginated data. Alternatively you can build your own `<Link>` component: `<Link to={previousPageUrl} state={state} preventScrollReset />` */
    PreviousLink: (props: Omit<LinkProps, 'to'> & {
        ref?: Ref<HTMLAnchorElement>;
    }) => ReactNode;
    /** The URL to the previous page of paginated data. Use this prop to build your own `<Link>` component. */
    previousPageUrl: string;
    /** The URL to the next page of paginated data. Use this prop to build your own `<Link>` component. */
    nextPageUrl: string;
    /** True if the cursor has next paginated data */
    hasNextPage: boolean;
    /** True if the cursor has previous paginated data */
    hasPreviousPage: boolean;
    /** True if we are in the process of fetching another page of data */
    isLoading: boolean;
    /** The `state` property is important to use when building your own `<Link>` component if you want paginated data to continuously append to the page. This means that every time the user clicks "Next page", the next page of data will be apppended inline with the previous page. If you want the whole page to re-render with only the next page results, do not pass the `state` prop to the Remix `<Link>` component. */
    state: {
        nodes: Array<NodesType>;
        pageInfo: {
            endCursor: Maybe<string> | undefined;
            startCursor: Maybe<string> | undefined;
            hasPreviousPage: boolean;
        };
    };
}
type PaginationProps<NodesType> = {
    /** The response from `storefront.query` for a paginated request. Make sure the query is passed pagination variables and that the query has `pageInfo` with `hasPreviousPage`, `hasNextpage`, `startCursor`, and `endCursor` defined. */
    connection: Connection<NodesType>;
    /** A render prop that includes pagination data and helpers. */
    children: PaginationRenderProp<NodesType>;
};
type PaginationRenderProp<NodesType> = (props: PaginationInfo<NodesType>) => ReactNode;
/**
 *
 * The [Storefront API uses cursors](https://shopify.dev/docs/api/usage/pagination-graphql) to paginate through lists of data
 * and the \`<Pagination />\` component makes it easy to paginate data from the Storefront API.
 *
 * @prop connection The response from `storefront.query` for a paginated request. Make sure the query is passed pagination variables and that the query has `pageInfo` with `hasPreviousPage`, `hasNextpage`, `startCursor`, and `endCursor` defined.
 * @prop children A render prop that includes pagination data and helpers.
 */
declare function Pagination<NodesType>({ connection, children, }: PaginationProps<NodesType>): ReactNode;
/**
 * @param request The request object passed to your Remix loader function.
 * @param options Options for how to configure the pagination variables. Includes the ability to change how many nodes are within each page.
 *
 * @returns Variables to be used with the `storefront.query` function
 */
declare function getPaginationVariables(request: Request, options?: {
    pageBy: number;
}): {
    last: number;
    startCursor: string | null;
} | {
    first: number;
    endCursor: string | null;
};

interface HydrogenSession {
    get: (key: string) => string | undefined;
    set: (key: string, value: string) => void;
    unset: (key: string) => void;
    commit: () => Promise<string>;
}

type CustomerAPIResponse<ReturnType> = {
    data: ReturnType;
    errors: Array<{
        message: string;
        locations?: Array<{
            line: number;
            column: number;
        }>;
        path?: Array<string>;
        extensions: {
            code: string;
        };
    }>;
    extensions: {
        cost: {
            requestQueryCost: number;
            actualQueryCakes: number;
            throttleStatus: {
                maximumAvailable: number;
                currentAvailable: number;
                restoreRate: number;
            };
        };
    };
};
type CustomerClient = {
    /** Start the OAuth login flow. This function should be called and returned from a Remix action. It redirects the user to a login domain. */
    login: () => Promise<Response>;
    /** On successful login, the user is redirect back to your app. This function validates the OAuth response and exchanges the authorization code for an access token and refresh token. It also persists the tokens on your session. This function should be called and returned from the Remix loader configured as the redirect URI within the Customer Account API settings. */
    authorize: (redirectPath?: string) => Promise<Response>;
    /** Returns if the user is logged in. It also checks if the access token is expired and refreshes it if needed. */
    isLoggedIn: () => Promise<boolean>;
    /** Logout the user by clearing the session and redirecting to the login domain. It should be called and returned from a Remix action. */
    logout: () => Promise<Response>;
    /** Execute a GraphQL query against the Customer Account API. Usually you should first check if the user is logged in before querying the API. */
    query: <ReturnType = any, RawGqlString extends string = string>(query: RawGqlString, options?: {
        variables: Record<string, any>;
    }) => Promise<CustomerAPIResponse<ReturnType>>;
    /** Execute a GraphQL mutation against the Customer Account API. Usually you should first check if the user is logged in before querying the API. */
    mutate: <ReturnType = any, RawGqlString extends string = string>(mutation: RawGqlString, options?: {
        variables: Record<string, any>;
    }) => Promise<CustomerAPIResponse<ReturnType>>;
};
type CustomerClientOptions = {
    /** The client requires a session to persist the auth and refresh token. By default Hydrogen ships with cookie session storage, but you can use [another session storage](https://remix.run/docs/en/main/utils/sessions) implementation.  */
    session: HydrogenSession;
    /** Unique UUID prefixed with `shp_` associated with the application, this should be visible in the customer account api settings in the Hydrogen admin channel. */
    customerAccountId: string;
    /** The account URL associated with the application, this should be visible in the customer account api settings in the Hydrogen admin channel. */
    customerAccountUrl: string;
    /** Override the version of the API */
    customerApiVersion?: string;
    /** The object for the current Request. It should be provided by your platform. */
    request: CrossRuntimeRequest;
    /** The waitUntil function is used to keep the current request/response lifecycle alive even after a response has been sent. It should be provided by your platform. */
    waitUntil?: ExecutionContext['waitUntil'];
};
declare function createCustomerClient({ session, customerAccountId, customerAccountUrl, customerApiVersion, request, waitUntil, }: CustomerClientOptions): CustomerClient;

/**
 * A custom Remix loader handler that fetches the changelog.json from GitHub.
 * It is used by the `upgrade` command inside the route `https://hydrogen.shopify.dev/changelog.json`
 */
declare function changelogHandler({ request, changelogUrl, }: {
    request: Request;
    changelogUrl?: string;
}): Promise<Response>;

type CartOptionalInput = {
    /**
     * The cart id.
     * @default cart.getCartId();
     */
    cartId?: Scalars['ID']['input'];
    /**
     * The country code.
     * @default storefront.i18n.country
     */
    country?: CountryCode;
    /**
     * The language code.
     * @default storefront.i18n.language
     */
    language?: LanguageCode;
};
type MetafieldWithoutOwnerId = Omit<CartMetafieldsSetInput, 'ownerId'>;
type CartQueryOptions = {
    /**
     * The storefront client instance created by [`createStorefrontClient`](docs/api/hydrogen/latest/utilities/createstorefrontclient).
     */
    storefront: Storefront;
    /**
     * A function that returns the cart ID.
     */
    getCartId: () => string | undefined;
    /**
     * The cart fragment to override the one used in this query.
     */
    cartFragment?: string;
};
type CartQueryData = {
    cart: Cart;
    errors?: CartUserError[] | MetafieldsSetUserError[] | MetafieldDeleteUserError[];
};
type CartQueryReturn<T> = (requiredParams: T, optionalParams?: CartOptionalInput) => Promise<CartQueryData>;

type OtherFormData = {
    [key: string]: unknown;
};
type CartAttributesUpdateProps = {
    action: 'AttributesUpdateInput';
    inputs?: {
        attributes: AttributeInput[];
    } & OtherFormData;
};
type CartAttributesUpdateRequire = {
    action: 'AttributesUpdateInput';
    inputs: {
        attributes: AttributeInput[];
    } & OtherFormData;
};
type CartBuyerIdentityUpdateProps = {
    action: 'BuyerIdentityUpdate';
    inputs?: {
        buyerIdentity: CartBuyerIdentityInput;
    } & OtherFormData;
};
type CartBuyerIdentityUpdateRequire = {
    action: 'BuyerIdentityUpdate';
    inputs: {
        buyerIdentity: CartBuyerIdentityInput;
    } & OtherFormData;
};
type CartCreateProps = {
    action: 'Create';
    inputs?: {
        input: CartInput;
    } & OtherFormData;
};
type CartCreateRequire = {
    action: 'Create';
    inputs: {
        input: CartInput;
    } & OtherFormData;
};
type CartDiscountCodesUpdateProps = {
    action: 'DiscountCodesUpdate';
    inputs?: {
        discountCodes: string[];
    } & OtherFormData;
};
type CartDiscountCodesUpdateRequire = {
    action: 'DiscountCodesUpdate';
    inputs: {
        discountCodes: string[];
    } & OtherFormData;
};
type CartLinesAddProps = {
    action: 'LinesAdd';
    inputs?: {
        lines: CartLineInput[];
    } & OtherFormData;
};
type CartLinesAddRequire = {
    action: 'LinesAdd';
    inputs: {
        lines: CartLineInput[];
    } & OtherFormData;
};
type CartLinesUpdateProps = {
    action: 'LinesUpdate';
    inputs?: {
        lines: CartLineUpdateInput[];
    } & OtherFormData;
};
type CartLinesUpdateRequire = {
    action: 'LinesUpdate';
    inputs: {
        lines: CartLineUpdateInput[];
    } & OtherFormData;
};
type CartLinesRemoveProps = {
    action: 'LinesRemove';
    inputs?: {
        lineIds: string[];
    } & OtherFormData;
};
type CartLinesRemoveRequire = {
    action: 'LinesRemove';
    inputs: {
        lineIds: string[];
    } & OtherFormData;
};
type CartNoteUpdateProps = {
    action: 'NoteUpdate';
    inputs?: {
        note: string;
    } & OtherFormData;
};
type CartNoteUpdateRequire = {
    action: 'NoteUpdate';
    inputs: {
        note: string;
    } & OtherFormData;
};
type CartSelectedDeliveryOptionsUpdateProps = {
    action: 'SelectedDeliveryOptionsUpdate';
    inputs?: {
        selectedDeliveryOptions: CartSelectedDeliveryOptionInput[];
    } & OtherFormData;
};
type CartSelectedDeliveryOptionsUpdateRequire = {
    action: 'SelectedDeliveryOptionsUpdate';
    inputs: {
        selectedDeliveryOptions: CartSelectedDeliveryOptionInput[];
    } & OtherFormData;
};
type CartMetafieldsSetProps = {
    action: 'MetafieldsSet';
    inputs?: {
        metafields: MetafieldWithoutOwnerId[];
    } & OtherFormData;
};
type CartMetafieldsSetRequire = {
    action: 'MetafieldsSet';
    inputs: {
        metafields: MetafieldWithoutOwnerId[];
    } & OtherFormData;
};
type CartMetafieldDeleteProps = {
    action: 'MetafieldsDelete';
    inputs?: {
        key: Scalars['String']['input'];
    } & OtherFormData;
};
type CartMetafieldDeleteRequire = {
    action: 'MetafieldsDelete';
    inputs: {
        key: Scalars['String']['input'];
    } & OtherFormData;
};
type CartCustomProps = {
    action: `Custom${string}`;
    inputs?: Record<string, unknown>;
};
type CartCustomRequire = {
    action: `Custom${string}`;
    inputs: Record<string, unknown>;
};
type CartFormCommonProps = {
    /**
     * Children nodes of CartForm.
     * Children can be a render prop that receives the fetcher.
     */
    children: ReactNode | ((fetcher: FetcherWithComponents<any>) => ReactNode);
    /**
     * The route to submit the form to. Defaults to the current route.
     */
    route?: string;
};
type CartActionInputProps = CartAttributesUpdateProps | CartBuyerIdentityUpdateProps | CartCreateProps | CartDiscountCodesUpdateProps | CartLinesAddProps | CartLinesUpdateProps | CartLinesRemoveProps | CartNoteUpdateProps | CartSelectedDeliveryOptionsUpdateProps | CartMetafieldsSetProps | CartMetafieldDeleteProps | CartCustomProps;
type CartActionInput = CartAttributesUpdateRequire | CartBuyerIdentityUpdateRequire | CartCreateRequire | CartDiscountCodesUpdateRequire | CartLinesAddRequire | CartLinesUpdateRequire | CartLinesRemoveRequire | CartNoteUpdateRequire | CartSelectedDeliveryOptionsUpdateRequire | CartMetafieldsSetRequire | CartMetafieldDeleteRequire | CartCustomRequire;
type CartFormProps = CartActionInputProps & CartFormCommonProps;
declare function CartForm({ children, action, inputs, route, }: CartFormProps): JSX.Element;
declare namespace CartForm {
    var INPUT_NAME: string;
    var ACTIONS: {
        readonly AttributesUpdateInput: "AttributesUpdateInput";
        readonly BuyerIdentityUpdate: "BuyerIdentityUpdate";
        readonly Create: "Create";
        readonly DiscountCodesUpdate: "DiscountCodesUpdate";
        readonly LinesAdd: "LinesAdd";
        readonly LinesRemove: "LinesRemove";
        readonly LinesUpdate: "LinesUpdate";
        readonly NoteUpdate: "NoteUpdate";
        readonly SelectedDeliveryOptionsUpdate: "SelectedDeliveryOptionsUpdate";
        readonly MetafieldsSet: "MetafieldsSet";
        readonly MetafieldDelete: "MetafieldDelete";
    };
    var getFormInput: (formData: FormData) => CartActionInput;
}

type CartCreateFunction = (input: CartInput, optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartCreateDefault(options: CartQueryOptions): CartCreateFunction;

type CartGetProps = {
    /**
     * The cart ID.
     * @default cart.getCartId();
     */
    cartId?: string;
    /**
     * The country code.
     * @default storefront.i18n.country
     */
    country?: CountryCode;
    /**
     * The language code.
     * @default storefront.i18n.language
     */
    language?: LanguageCode;
    /**
     * The number of cart lines to be returned.
     * @default 100
     */
    numCartLines?: number;
};
type CartGetFunction = (cartInput?: CartGetProps) => Promise<Cart | null>;
declare function cartGetDefault(options: CartQueryOptions): CartGetFunction;

type CartLinesAddFunction = (lines: CartLineInput[], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartLinesAddDefault(options: CartQueryOptions): CartLinesAddFunction;

type CartLinesUpdateFunction = (lines: CartLineUpdateInput[], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartLinesUpdateDefault(options: CartQueryOptions): CartLinesUpdateFunction;

type CartLinesRemoveFunction = (lineIds: string[], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartLinesRemoveDefault(options: CartQueryOptions): CartLinesRemoveFunction;

type CartDiscountCodesUpdateFunction = (discountCodes: string[], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartDiscountCodesUpdateDefault(options: CartQueryOptions): CartDiscountCodesUpdateFunction;

type CartBuyerIdentityUpdateFunction = (buyerIdentity: CartBuyerIdentityInput, optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartBuyerIdentityUpdateDefault(options: CartQueryOptions): CartBuyerIdentityUpdateFunction;

type CartNoteUpdateFunction = (note: string, optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartNoteUpdateDefault(options: CartQueryOptions): CartNoteUpdateFunction;

type CartSelectedDeliveryOptionsUpdateFunction = (selectedDeliveryOptions: CartSelectedDeliveryOptionInput[], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartSelectedDeliveryOptionsUpdateDefault(options: CartQueryOptions): CartSelectedDeliveryOptionsUpdateFunction;

type CartAttributesUpdateFunction = (attributes: AttributeInput[], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartAttributesUpdateDefault(options: CartQueryOptions): CartAttributesUpdateFunction;

type CartMetafieldsSetFunction = (metafields: MetafieldWithoutOwnerId[], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartMetafieldsSetDefault(options: CartQueryOptions): CartMetafieldsSetFunction;

type CartMetafieldDeleteFunction = (key: Scalars['String']['input'], optionalParams?: CartOptionalInput) => Promise<CartQueryData>;
declare function cartMetafieldDeleteDefault(options: CartQueryOptions): CartMetafieldDeleteFunction;

declare const cartGetIdDefault: (requestHeaders: Headers) => () => string | undefined;

type CookieOptions = {
    maxage?: number;
    expires?: Date | number | string;
    samesite?: 'Lax' | 'Strict' | 'None';
    secure?: boolean;
    httponly?: boolean;
    domain?: string;
    path?: string;
};
declare const cartSetIdDefault: (cookieOptions?: CookieOptions) => (cartId: string) => Headers;

type CartHandlerOptions = {
    storefront: Storefront;
    getCartId: () => string | undefined;
    setCartId: (cartId: string) => Headers;
    cartQueryFragment?: string;
    cartMutateFragment?: string;
};
type CustomMethodsBase = Record<string, Function>;
type CartHandlerOptionsWithCustom<TCustomMethods extends CustomMethodsBase> = CartHandlerOptions & {
    customMethods?: TCustomMethods;
};
type HydrogenCart = {
    get: ReturnType<typeof cartGetDefault>;
    getCartId: () => string | undefined;
    setCartId: (cartId: string) => Headers;
    create: ReturnType<typeof cartCreateDefault>;
    addLines: ReturnType<typeof cartLinesAddDefault>;
    updateLines: ReturnType<typeof cartLinesUpdateDefault>;
    removeLines: ReturnType<typeof cartLinesRemoveDefault>;
    updateDiscountCodes: ReturnType<typeof cartDiscountCodesUpdateDefault>;
    updateBuyerIdentity: ReturnType<typeof cartBuyerIdentityUpdateDefault>;
    updateNote: ReturnType<typeof cartNoteUpdateDefault>;
    updateSelectedDeliveryOption: ReturnType<typeof cartSelectedDeliveryOptionsUpdateDefault>;
    updateAttributes: ReturnType<typeof cartAttributesUpdateDefault>;
    setMetafields: ReturnType<typeof cartMetafieldsSetDefault>;
    deleteMetafield: ReturnType<typeof cartMetafieldDeleteDefault>;
};
type HydrogenCartCustom<TCustomMethods extends Partial<HydrogenCart>> = Omit<HydrogenCart, keyof TCustomMethods> & TCustomMethods;
declare function createCartHandler(options: CartHandlerOptions): HydrogenCart;
declare function createCartHandler<TCustomMethods extends CustomMethodsBase>(options: CartHandlerOptionsWithCustom<TCustomMethods>): HydrogenCartCustom<TCustomMethods>;

type VariantOption = {
    name: string;
    value?: string;
    values: Array<VariantOptionValue>;
};
type VariantOptionValue = {
    value: string;
    isAvailable: boolean;
    to: string;
    search: string;
    isActive: boolean;
};
type VariantSelectorProps = {
    /** The product handle for all of the variants */
    handle: string;
    /** Product options from the [Storefront API](/docs/api/storefront/2023-10/objects/ProductOption). Make sure both `name` and `values` are apart of your query. */
    options: Array<PartialDeep<ProductOption>> | undefined;
    /** Product variants from the [Storefront API](/docs/api/storefront/2023-10/objects/ProductVariant). You only need to pass this prop if you want to show product availability. If a product option combination is not found within `variants`, it is assumed to be available. Make sure to include `availableForSale` and `selectedOptions.name` and `selectedOptions.value`. */
    variants?: PartialDeep<ProductVariantConnection> | Array<PartialDeep<ProductVariant>>;
    /** By default all products are under /products. Use this prop to provide a custom path. */
    productPath?: string;
    children: ({ option }: {
        option: VariantOption;
    }) => ReactNode;
};
declare function VariantSelector({ handle, options, variants: _variants, productPath, children, }: VariantSelectorProps): react.FunctionComponentElement<{
    children?: ReactNode;
}>;
type GetSelectedProductOptions = (request: Request) => SelectedOptionInput[];
declare const getSelectedProductOptions: GetSelectedProductOptions;

declare const useNonce: () => string | undefined;
type ContentSecurityPolicy = {
    /** A randomly generated nonce string that should be passed to any custom `script` element */
    nonce: string;
    /** The content security policy header */
    header: string;
    NonceProvider: ComponentType<{
        children: ReactNode;
    }>;
};
/**
 * @param directives - Pass custom [content security policy directives](https://content-security-policy.com/). This is important if you load content in your app from third-party domains.
 */
declare function createContentSecurityPolicy(directives?: Record<string, string[] | string | boolean>): ContentSecurityPolicy;

declare const Script: react.ForwardRefExoticComponent<Omit<react.DetailedHTMLProps<react.ScriptHTMLAttributes<HTMLScriptElement>, HTMLScriptElement>, "ref"> & react.RefAttributes<HTMLScriptElement>>;

declare function useOptimisticData<T>(identifier: string): T;
type OptimisticInputProps = {
    /**
     * A unique identifier for the optimistic input. Use the same identifier in `useOptimisticData`
     * to retrieve the optimistic data from actions.
     */
    id: string;
    /**
     * The data to be stored in the optimistic input. Use for creating an optimistic successful state
     * of this form action.
     */
    data: Record<string, unknown>;
};
declare function OptimisticInput({ id, data }: OptimisticInputProps): react_jsx_runtime.JSX.Element;

declare function ShopPayButton(props: ComponentProps<typeof ShopPayButton$1>): react_jsx_runtime.JSX.Element;

export { CacheCustom, CacheKey, CacheLong, CacheNone, CacheShort, CachingStrategy, CartActionInput, CartForm, CartQueryData, CartQueryOptions, CartQueryReturn, CookieOptions, CreateStorefrontClientOptions, CustomerClient, HydrogenCart, HydrogenCartCustom, I18nBase, InMemoryCache, MetafieldWithoutOwnerId, NoStoreStrategy, OptimisticInput, Pagination, Script, Seo, SeoConfig, SeoHandleFunction, ShopPayButton, Storefront, StorefrontApiError, StorefrontClient, StorefrontMutations, StorefrontQueries, VariantOption, VariantOptionValue, VariantSelector, WithCache, cartAttributesUpdateDefault, cartBuyerIdentityUpdateDefault, cartCreateDefault, cartDiscountCodesUpdateDefault, cartGetDefault, cartGetIdDefault, cartLinesAddDefault, cartLinesRemoveDefault, cartLinesUpdateDefault, cartMetafieldDeleteDefault, cartMetafieldsSetDefault, cartNoteUpdateDefault, cartSelectedDeliveryOptionsUpdateDefault, cartSetIdDefault, changelogHandler, createCartHandler, createContentSecurityPolicy, createCustomerClient as createCustomerClient__unstable, createStorefrontClient, createWithCache, generateCacheControlHeader, getPaginationVariables, getSelectedProductOptions, graphiqlLoader, isStorefrontApiError, storefrontRedirect, useNonce, useOptimisticData };
