import { createStorefrontClient as createStorefrontClient$1, SHOPIFY_STOREFRONT_ID_HEADER, getShopifyCookies, SHOPIFY_Y, SHOPIFY_STOREFRONT_Y_HEADER, SHOPIFY_S, SHOPIFY_STOREFRONT_S_HEADER, flattenConnection, ShopPayButton as ShopPayButton$1 } from '@shopify/hydrogen-react';
export { AnalyticsEventName, AnalyticsPageType, ExternalVideo, IMAGE_FRAGMENT, Image, MediaFile, ModelViewer, Money, ShopifySalesChannel, Video, flattenConnection, getClientBrowserParameters, getShopifyCookies, parseGid, parseMetafield, sendShopifyAnalytics, storefrontApiCustomScalars, useLoadScript, useMoney, useShopifyCookies } from '@shopify/hydrogen-react';
import { redirect } from '@remix-run/server-runtime';
import { lazy, createContext, forwardRef, useMemo, createElement, Suspense, Fragment, useRef, useEffect, useContext } from 'react';
import { useMatches, useLocation, useNavigation, Link, useNavigate, useFetcher, useFetchers } from '@remix-run/react';
import { jsx, jsxs, Fragment as Fragment$1 } from 'react/jsx-runtime';
import cspBuilder from 'content-security-policy-builder';

// src/storefront.ts

// src/utils/hash.ts
function hashKey(queryKey) {
  const rawKeys = Array.isArray(queryKey) ? queryKey : [queryKey];
  let hash = "";
  for (const key of rawKeys) {
    if (key != null) {
      if (typeof key === "object") {
        hash += JSON.stringify(key);
      } else {
        hash += key.toString();
      }
    }
  }
  return encodeURIComponent(hash);
}

// src/cache/strategies.ts
var PUBLIC = "public";
var PRIVATE = "private";
var NO_STORE = "no-store";
var optionMapping = {
  maxAge: "max-age",
  staleWhileRevalidate: "stale-while-revalidate",
  sMaxAge: "s-maxage",
  staleIfError: "stale-if-error"
};
function generateCacheControlHeader(cacheOptions) {
  const cacheControl = [];
  Object.keys(cacheOptions).forEach((key) => {
    if (key === "mode") {
      cacheControl.push(cacheOptions[key]);
    } else if (optionMapping[key]) {
      cacheControl.push(
        `${optionMapping[key]}=${cacheOptions[key]}`
      );
    }
  });
  return cacheControl.join(", ");
}
function CacheNone() {
  return {
    mode: NO_STORE
  };
}
function guardExpirableModeType(overrideOptions) {
  if (overrideOptions?.mode && overrideOptions?.mode !== PUBLIC && overrideOptions?.mode !== PRIVATE) {
    throw Error("'mode' must be either 'public' or 'private'");
  }
}
function CacheShort(overrideOptions) {
  guardExpirableModeType(overrideOptions);
  return {
    mode: PUBLIC,
    maxAge: 1,
    staleWhileRevalidate: 9,
    ...overrideOptions
  };
}
function CacheLong(overrideOptions) {
  guardExpirableModeType(overrideOptions);
  return {
    mode: PUBLIC,
    maxAge: 3600,
    // 1 hour
    staleWhileRevalidate: 82800,
    // 23 Hours
    ...overrideOptions
  };
}
function CacheDefault(overrideOptions) {
  guardExpirableModeType(overrideOptions);
  return {
    mode: PUBLIC,
    maxAge: 1,
    staleWhileRevalidate: 86399,
    // 1 second less than 24 hours
    ...overrideOptions
  };
}
function CacheCustom(overrideOptions) {
  return overrideOptions;
}

// src/utils/parse-json.ts
function parseJSON(json) {
  if (String(json).includes("__proto__"))
    return JSON.parse(json, noproto);
  return JSON.parse(json);
}
function noproto(k, v) {
  if (k !== "__proto__")
    return v;
}
function getCacheControlSetting(userCacheOptions, options) {
  if (userCacheOptions && options) {
    return {
      ...userCacheOptions,
      ...options
    };
  } else {
    return userCacheOptions || CacheDefault();
  }
}
function generateDefaultCacheControlHeader(userCacheOptions) {
  return generateCacheControlHeader(getCacheControlSetting(userCacheOptions));
}
async function getItem(cache, request) {
  if (!cache)
    return;
  const response = await cache.match(request);
  if (!response) {
    return;
  }
  return response;
}
async function setItem(cache, request, response, userCacheOptions) {
  if (!cache)
    return;
  const cacheControl = getCacheControlSetting(userCacheOptions);
  const paddedCacheControlString = generateDefaultCacheControlHeader(
    getCacheControlSetting(cacheControl, {
      maxAge: (cacheControl.maxAge || 0) + (cacheControl.staleWhileRevalidate || 0)
    })
  );
  const cacheControlString = generateDefaultCacheControlHeader(
    getCacheControlSetting(cacheControl)
  );
  response.headers.set("cache-control", paddedCacheControlString);
  response.headers.set("real-cache-control", cacheControlString);
  response.headers.set("cache-put-date", (/* @__PURE__ */ new Date()).toUTCString());
  await cache.put(request, response);
}
async function deleteItem(cache, request) {
  if (!cache)
    return;
  await cache.delete(request);
}
function calculateAge(response, responseDate) {
  const cacheControl = response.headers.get("real-cache-control");
  let responseMaxAge = 0;
  if (cacheControl) {
    const maxAgeMatch = cacheControl.match(/max-age=(\d*)/);
    if (maxAgeMatch && maxAgeMatch.length > 1) {
      responseMaxAge = parseFloat(maxAgeMatch[1]);
    }
  }
  const ageInMs = (/* @__PURE__ */ new Date()).valueOf() - new Date(responseDate).valueOf();
  return [ageInMs / 1e3, responseMaxAge];
}
function isStale(request, response) {
  const responseDate = response.headers.get("cache-put-date");
  if (!responseDate) {
    return false;
  }
  const [age, responseMaxAge] = calculateAge(response, responseDate);
  const result = age > responseMaxAge;
  return result;
}
var CacheAPI = {
  get: getItem,
  set: setItem,
  delete: deleteItem,
  generateDefaultCacheControlHeader,
  isStale
};

// src/cache/sub-request.ts
function getKeyUrl(key) {
  return `https://shopify.dev/?${key}`;
}
function getCacheOption(userCacheOptions) {
  return userCacheOptions || CacheDefault();
}
async function getItemFromCache(cache, key) {
  if (!cache)
    return;
  const url = getKeyUrl(key);
  const request = new Request(url);
  const response = await CacheAPI.get(cache, request);
  if (!response) {
    return;
  }
  const text = await response.text();
  try {
    return [parseJSON(text), response];
  } catch {
    return [text, response];
  }
}
async function setItemInCache(cache, key, value, userCacheOptions) {
  if (!cache)
    return;
  const url = getKeyUrl(key);
  const request = new Request(url);
  const response = new Response(JSON.stringify(value));
  await CacheAPI.set(
    cache,
    request,
    response,
    getCacheOption(userCacheOptions)
  );
}
function isStale2(key, response) {
  return CacheAPI.isStale(new Request(getKeyUrl(key)), response);
}

// src/cache/fetch.ts
function toSerializableResponse(body, response) {
  return [
    body,
    {
      status: response.status,
      statusText: response.statusText,
      headers: Array.from(response.headers.entries())
    }
  ];
}
function fromSerializableResponse([body, init]) {
  return [body, new Response(body, init)];
}
var checkGraphQLErrors = (body) => !body?.errors;
var swrLock = /* @__PURE__ */ new Set();
async function runWithCache(cacheKey, actionFn, {
  strategy = CacheShort(),
  cacheInstance,
  shouldCacheResult = () => true,
  waitUntil,
  debugInfo
}) {
  const startTime = Date.now();
  const key = hashKey([
    // '__HYDROGEN_CACHE_ID__', // TODO purgeQueryCacheOnBuild
    ...typeof cacheKey === "string" ? [cacheKey] : cacheKey
  ]);
  const logSubRequestEvent = (cacheStatus, overrideStartTime) => {
    globalThis.__H2O_LOG_EVENT?.({
      eventType: "subrequest",
      url: getKeyUrl(key),
      startTime: overrideStartTime || startTime,
      cacheStatus,
      waitUntil,
      ...debugInfo
    });
  } ;
  if (!cacheInstance || !strategy || strategy.mode === NO_STORE) {
    const result2 = await actionFn();
    logSubRequestEvent?.();
    return result2;
  }
  const cachedItem = await getItemFromCache(cacheInstance, key);
  if (cachedItem) {
    const [cachedResult, cacheInfo] = cachedItem;
    const cacheStatus = isStale2(key, cacheInfo) ? "STALE" : "HIT";
    if (!swrLock.has(key) && cacheStatus === "STALE") {
      swrLock.add(key);
      const revalidatingPromise = Promise.resolve().then(async () => {
        const revalidateStartTime = Date.now();
        try {
          const result2 = await actionFn();
          if (shouldCacheResult(result2)) {
            await setItemInCache(cacheInstance, key, result2, strategy);
            logSubRequestEvent?.("PUT", revalidateStartTime);
          }
        } catch (error) {
          if (error.message) {
            error.message = "SWR in sub-request failed: " + error.message;
          }
          console.error(error);
        } finally {
          swrLock.delete(key);
        }
      });
      waitUntil?.(revalidatingPromise);
    }
    logSubRequestEvent?.(cacheStatus);
    return cachedResult;
  }
  const result = await actionFn();
  logSubRequestEvent?.("MISS");
  if (shouldCacheResult(result)) {
    const setItemInCachePromise = Promise.resolve().then(async () => {
      const putStartTime = Date.now();
      await setItemInCache(cacheInstance, key, result, strategy);
      logSubRequestEvent?.("PUT", putStartTime);
    });
    waitUntil?.(setItemInCachePromise);
  }
  return result;
}
async function fetchWithServerCache(url, requestInit, {
  cacheInstance,
  cache: cacheOptions,
  cacheKey = [url, requestInit],
  shouldCacheResponse = () => true,
  waitUntil,
  returnType = "json",
  debugInfo
} = {}) {
  if (!cacheOptions && (!requestInit.method || requestInit.method === "GET")) {
    cacheOptions = CacheShort();
  }
  return runWithCache(
    cacheKey,
    async () => {
      const response = await fetch(url, requestInit);
      let data;
      try {
        data = await response[returnType]();
      } catch {
        try {
          data = await response.text();
        } catch {
          throw new Error(
            `Storefront API response code: ${response.status} (Request Id: ${response.headers.get("x-request-id")})`
          );
        }
      }
      return toSerializableResponse(data, response);
    },
    {
      cacheInstance,
      waitUntil,
      strategy: cacheOptions ?? null,
      debugInfo,
      shouldCacheResult: (result) => shouldCacheResponse(...fromSerializableResponse(result))
    }
  ).then(fromSerializableResponse);
}

// src/constants.ts
var STOREFRONT_REQUEST_GROUP_ID_HEADER = "Custom-Storefront-Request-Group-ID";
var STOREFRONT_ACCESS_TOKEN_HEADER = "X-Shopify-Storefront-Access-Token";
var SDK_VARIANT_HEADER = "X-SDK-Variant";
var SDK_VARIANT_SOURCE_HEADER = "X-SDK-Variant-Source";
var SDK_VERSION_HEADER = "X-SDK-Version";

// src/utils/uuid.ts
function generateUUID() {
  if (typeof crypto !== "undefined" && !!crypto.randomUUID) {
    return crypto.randomUUID();
  } else {
    return `weak-${Math.random().toString(16).substring(2)}`;
  }
}

// src/utils/warning.ts
var warnings = /* @__PURE__ */ new Set();
var warnOnce = (string) => {
  if (!warnings.has(string)) {
    console.warn(string);
    warnings.add(string);
  }
};

// src/version.ts
var LIB_VERSION = "2023.10.4";

// src/utils/graphql.ts
function minifyQuery(string) {
  return string.replace(/\s*#.*$/gm, "").replace(/\s+/gm, " ").trim();
}
var IS_QUERY_RE = /(^|}\s)query[\s({]/im;
var IS_MUTATION_RE = /(^|}\s)mutation[\s({]/im;
function assertQuery(query, callerName) {
  if (!IS_QUERY_RE.test(query)) {
    throw new Error(`[h2:error:${callerName}] Can only execute queries`);
  }
}
function assertMutation(query, callerName) {
  if (!IS_MUTATION_RE.test(query)) {
    throw new Error(`[h2:error:${callerName}] Can only execute mutations`);
  }
}
function throwGraphQLError({
  response,
  errors,
  type,
  query,
  queryVariables,
  ErrorConstructor = Error,
  client = "storefront"
}) {
  const requestId = response.headers.get("x-request-id");
  const errorMessage = (typeof errors === "string" ? errors : errors?.map?.((error) => error.message).join("\n")) || `API response error: ${response.status}`;
  throw new ErrorConstructor(
    `[h2:error:${client}.${type}] ` + errorMessage + (requestId ? ` - Request ID: ${requestId}` : ""),
    {
      cause: JSON.stringify({
        errors,
        requestId,
        ...{
          graphql: {
            query,
            variables: JSON.stringify(queryVariables)
          }
        }
      })
    }
  );
}

// src/storefront.ts
var StorefrontApiError = class extends Error {
};
var isStorefrontApiError = (error) => error instanceof StorefrontApiError;
var defaultI18n = { language: "EN", country: "US" };
function createStorefrontClient(options) {
  const {
    storefrontHeaders,
    cache,
    waitUntil,
    i18n,
    storefrontId,
    ...clientOptions
  } = options;
  const H2_PREFIX_WARN = "[h2:warn:createStorefrontClient] ";
  if (!cache) {
    warnOnce(
      H2_PREFIX_WARN + "Storefront API client created without a cache instance. This may slow down your sub-requests."
    );
  }
  const {
    getPublicTokenHeaders,
    getPrivateTokenHeaders,
    getStorefrontApiUrl,
    getShopifyDomain
  } = createStorefrontClient$1(clientOptions);
  const getHeaders = clientOptions.privateStorefrontToken ? getPrivateTokenHeaders : getPublicTokenHeaders;
  const defaultHeaders = getHeaders({
    contentType: "json",
    buyerIp: storefrontHeaders?.buyerIp || ""
  });
  defaultHeaders[STOREFRONT_REQUEST_GROUP_ID_HEADER] = storefrontHeaders?.requestGroupId || generateUUID();
  if (storefrontId)
    defaultHeaders[SHOPIFY_STOREFRONT_ID_HEADER] = storefrontId;
  defaultHeaders["user-agent"] = `Hydrogen ${LIB_VERSION}`;
  if (storefrontHeaders && storefrontHeaders.cookie) {
    const cookies = getShopifyCookies(storefrontHeaders.cookie ?? "");
    if (cookies[SHOPIFY_Y])
      defaultHeaders[SHOPIFY_STOREFRONT_Y_HEADER] = cookies[SHOPIFY_Y];
    if (cookies[SHOPIFY_S])
      defaultHeaders[SHOPIFY_STOREFRONT_S_HEADER] = cookies[SHOPIFY_S];
  }
  const cacheKeyHeader = JSON.stringify({
    "content-type": defaultHeaders["content-type"],
    "user-agent": defaultHeaders["user-agent"],
    [SDK_VARIANT_HEADER]: defaultHeaders[SDK_VARIANT_HEADER],
    [SDK_VARIANT_SOURCE_HEADER]: defaultHeaders[SDK_VARIANT_SOURCE_HEADER],
    [SDK_VERSION_HEADER]: defaultHeaders[SDK_VERSION_HEADER],
    [STOREFRONT_ACCESS_TOKEN_HEADER]: defaultHeaders[STOREFRONT_ACCESS_TOKEN_HEADER]
  });
  async function fetchStorefrontApi({
    query,
    mutation,
    variables,
    cache: cacheOptions,
    headers = [],
    storefrontApiVersion
  }) {
    const userHeaders = headers instanceof Headers ? Object.fromEntries(headers.entries()) : Array.isArray(headers) ? Object.fromEntries(headers) : headers;
    query = query ?? mutation;
    const queryVariables = { ...variables };
    if (i18n) {
      if (!variables?.country && /\$country/.test(query)) {
        queryVariables.country = i18n.country;
      }
      if (!variables?.language && /\$language/.test(query)) {
        queryVariables.language = i18n.language;
      }
    }
    const url = getStorefrontApiUrl({ storefrontApiVersion });
    const graphqlData = JSON.stringify({ query, variables: queryVariables });
    const requestInit = {
      method: "POST",
      headers: { ...defaultHeaders, ...userHeaders },
      body: graphqlData
    };
    const cacheKey = [
      url,
      requestInit.method,
      cacheKeyHeader,
      requestInit.body
    ];
    const [body, response] = await fetchWithServerCache(url, requestInit, {
      cacheInstance: mutation ? void 0 : cache,
      cache: cacheOptions || CacheDefault(),
      cacheKey,
      shouldCacheResponse: checkGraphQLErrors,
      waitUntil,
      debugInfo: {
        graphql: graphqlData,
        requestId: requestInit.headers[STOREFRONT_REQUEST_GROUP_ID_HEADER],
        purpose: storefrontHeaders?.purpose
      }
    });
    const errorOptions = {
      response,
      type: mutation ? "mutation" : "query",
      query,
      queryVariables,
      errors: void 0
    };
    if (!response.ok) {
      let errors2;
      try {
        errors2 = parseJSON(body);
      } catch (_e) {
        errors2 = [{ message: body }];
      }
      throwGraphQLError({ ...errorOptions, errors: errors2 });
    }
    const { data, errors } = body;
    if (errors?.length) {
      throwGraphQLError({
        ...errorOptions,
        errors,
        ErrorConstructor: StorefrontApiError
      });
    }
    return data;
  }
  return {
    storefront: {
      /**
       * Sends a GraphQL query to the Storefront API.
       *
       * Example:
       *
       * ```js
       * async function loader ({context: {storefront}}) {
       *   const data = await storefront.query('query { ... }', {
       *     variables: {},
       *     cache: storefront.CacheLong()
       *   });
       * }
       * ```
       */
      query: (query, payload) => {
        query = minifyQuery(query);
        assertQuery(query, "storefront.query");
        const result = fetchStorefrontApi({
          ...payload,
          query
        });
        result.catch(() => {
        });
        return result;
      },
      /**
       * Sends a GraphQL mutation to the Storefront API.
       *
       * Example:
       *
       * ```js
       * async function loader ({context: {storefront}}) {
       *   await storefront.mutate('mutation { ... }', {
       *     variables: {},
       *   });
       * }
       * ```
       */
      mutate: (mutation, payload) => {
        mutation = minifyQuery(mutation);
        assertMutation(mutation, "storefront.mutate");
        const result = fetchStorefrontApi({
          ...payload,
          mutation
        });
        result.catch(() => {
        });
        return result;
      },
      cache,
      CacheNone,
      CacheLong,
      CacheShort,
      CacheCustom,
      generateCacheControlHeader,
      getPublicTokenHeaders,
      getPrivateTokenHeaders,
      getShopifyDomain,
      getApiUrl: getStorefrontApiUrl,
      /**
       * Wether it's a GraphQL error returned in the Storefront API response.
       *
       * Example:
       *
       * ```js
       * async function loader ({context: {storefront}}) {
       *   try {
       *     await storefront.query(...);
       *   } catch(error) {
       *     if (storefront.isApiError(error)) {
       *       // ...
       *     }
       *
       *     throw error;
       *   }
       * }
       * ```
       */
      isApiError: isStorefrontApiError,
      i18n: i18n ?? defaultI18n
    }
  };
}

// src/utils/request.ts
function getHeader(request, key) {
  const value = request.headers?.get?.(key) ?? request.headers?.[key];
  return typeof value === "string" ? value : null;
}
function getDebugHeaders(request) {
  return request ? {
    requestId: getHeader(request, "request-id"),
    purpose: getHeader(request, "purpose")
  } : {};
}

// src/with-cache.ts
function createWithCache({
  cache,
  waitUntil,
  request
}) {
  return function withCache(cacheKey, strategy, actionFn) {
    return runWithCache(cacheKey, actionFn, {
      strategy,
      cacheInstance: cache,
      waitUntil,
      debugInfo: getDebugHeaders(request)
    });
  };
}

// src/cache/in-memory.ts
var InMemoryCache = class {
  #store;
  constructor() {
    this.#store = /* @__PURE__ */ new Map();
  }
  add(request) {
    throw new Error("Method not implemented. Use `put` instead.");
  }
  addAll(requests) {
    throw new Error("Method not implemented. Use `put` instead.");
  }
  matchAll(request, options) {
    throw new Error("Method not implemented. Use `match` instead.");
  }
  async put(request, response) {
    if (request.method !== "GET") {
      throw new TypeError("Cannot cache response to non-GET request.");
    }
    if (response.status === 206) {
      throw new TypeError(
        "Cannot cache response to a range request (206 Partial Content)."
      );
    }
    if (response.headers.get("vary")?.includes("*")) {
      throw new TypeError("Cannot cache response with 'Vary: *' header.");
    }
    this.#store.set(request.url, {
      body: new Uint8Array(await response.arrayBuffer()),
      status: response.status,
      headers: [...response.headers],
      timestamp: Date.now()
    });
  }
  async match(request) {
    if (request.method !== "GET")
      return;
    const match = this.#store.get(request.url);
    if (!match) {
      return;
    }
    const { body, timestamp, ...metadata } = match;
    const headers = new Headers(metadata.headers);
    const cacheControl = headers.get("cache-control") || headers.get("real-cache-control") || "";
    const maxAge = parseInt(
      cacheControl.match(/max-age=(\d+)/)?.[1] || "0",
      10
    );
    const swr = parseInt(
      cacheControl.match(/stale-while-revalidate=(\d+)/)?.[1] || "0",
      10
    );
    const age = (Date.now() - timestamp) / 1e3;
    const isMiss = age > maxAge + swr;
    if (isMiss) {
      this.#store.delete(request.url);
      return;
    }
    const isStale3 = age > maxAge;
    headers.set("cache", isStale3 ? "STALE" : "HIT");
    headers.set("date", new Date(timestamp).toUTCString());
    return new Response(body, {
      status: metadata.status ?? 200,
      headers
    });
  }
  async delete(request) {
    if (this.#store.has(request.url)) {
      this.#store.delete(request.url);
      return true;
    }
    return false;
  }
  keys(request) {
    const cacheKeys = [];
    for (const url of this.#store.keys()) {
      if (!request || request.url === url) {
        cacheKeys.push(new Request(url));
      }
    }
    return Promise.resolve(cacheKeys);
  }
};
async function storefrontRedirect(options) {
  const {
    storefront,
    request,
    noAdminRedirect,
    response = new Response("Not Found", { status: 404 })
  } = options;
  const { pathname, search } = new URL(request.url);
  const redirectFrom = pathname + search;
  if (pathname === "/admin" && !noAdminRedirect) {
    return redirect(`${storefront.getShopifyDomain()}/admin`);
  }
  try {
    const { urlRedirects } = await storefront.query(REDIRECT_QUERY, {
      variables: { query: "path:" + redirectFrom }
    });
    const location = urlRedirects?.edges?.[0]?.node?.target;
    if (location) {
      return new Response(null, { status: 301, headers: { location } });
    }
    const searchParams = new URLSearchParams(search);
    const redirectTo = searchParams.get("return_to") || searchParams.get("redirect");
    if (redirectTo) {
      if (isLocalPath(request.url, redirectTo)) {
        return redirect(redirectTo);
      } else {
        console.warn(
          `Cross-domain redirects are not supported. Tried to redirect from ${redirectFrom} to ${redirectTo}`
        );
      }
    }
  } catch (error) {
    console.error(
      `Failed to fetch redirects from Storefront API for route ${redirectFrom}`,
      error
    );
  }
  return response;
}
function isLocalPath(requestUrl, redirectUrl) {
  try {
    return new URL(requestUrl).origin === new URL(redirectUrl, requestUrl).origin;
  } catch (e) {
    return false;
  }
}
var REDIRECT_QUERY = `#graphql
  query redirects($query: String) {
    urlRedirects(first: 1, query: $query) {
      edges {
        node {
          target
        }
      }
    }
  }
`;

// src/routing/graphiql.ts
var graphiqlLoader = async function graphiqlLoader2({
  context
}) {
  const storefront = context?.storefront;
  if (!storefront) {
    throw new Error(
      `GraphiQL: Hydrogen's storefront client must be injected in the loader context.`
    );
  }
  const url = storefront.getApiUrl();
  const accessToken = storefront.getPublicTokenHeaders()["X-Shopify-Storefront-Access-Token"];
  const favicon = `https://avatars.githubusercontent.com/u/12972006?s=48&v=4`;
  const html = String.raw;
  return new Response(
    html`
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <title>GraphiQL</title>
          <link rel="icon" type="image/x-icon" href="${favicon}" />
          <style>
            body {
              height: 100%;
              margin: 0;
              width: 100%;
              overflow: hidden;
              background-color: hsl(219, 29%, 18%);
            }

            #graphiql {
              height: 100vh;
            }

            #graphiql > .placeholder {
              color: slategray;
              width: fit-content;
              margin: 40px auto;
              font-family: Arial;
            }
          </style>

          <script
            crossorigin
            src="https://unpkg.com/react@18/umd/react.development.js"
          ></script>
          <script
            crossorigin
            src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"
          ></script>
          <link
            rel="stylesheet"
            href="https://unpkg.com/graphiql@3/graphiql.min.css"
          />
          <link
            rel="stylesheet"
            href="https://unpkg.com/@graphiql/plugin-explorer/dist/style.css"
          />
        </head>

        <body>
          <div id="graphiql">
            <div class="placeholder">Loading GraphiQL...</div>
          </div>

          <script
            src="https://unpkg.com/graphiql@3/graphiql.min.js"
            type="application/javascript"
            crossorigin="anonymous"
          ></script>
          <script
            src="https://unpkg.com/@graphiql/plugin-explorer/dist/index.umd.js"
            type="application/javascript"
            crossorigin="anonymous"
          ></script>

          <script>
            const windowUrl = new URL(document.URL);

            let query = '{ shop { name } }';
            if (windowUrl.searchParams.has('query')) {
              query = decodeURIComponent(
                windowUrl.searchParams.get('query') ?? query,
              );
            }

            // Prettify query
            query = GraphiQL.GraphQL.print(GraphiQL.GraphQL.parse(query));

            let variables;
            if (windowUrl.searchParams.has('variables')) {
              variables = decodeURIComponent(
                windowUrl.searchParams.get('variables') ?? '',
              );
            }

            // Prettify variables
            if (variables) {
              variables = JSON.stringify(JSON.parse(variables), null, 2);
            }

            const root = ReactDOM.createRoot(
              document.getElementById('graphiql'),
            );
            root.render(
              React.createElement(GraphiQL, {
                fetcher: GraphiQL.createFetcher({
                  url: '${url}',
                  headers: {
                    'X-Shopify-Storefront-Access-Token': '${accessToken}',
                  },
                }),
                defaultEditorToolsVisibility: true,
                query,
                variables,
                plugins: [GraphiQLPluginExplorer.explorerPlugin()],
              }),
            );
          </script>
        </body>
      </html>
    `,
    { status: 200, headers: { "content-type": "text/html" } }
  );
};

// src/seo/generate-seo-tags.ts
var ERROR_PREFIX = "Error in SEO input: ";
var schema = {
  title: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(ERROR_PREFIX.concat("`title` should be a string"));
      }
      if (typeof value === "string" && value.length > 120) {
        throw new Error(
          ERROR_PREFIX.concat(
            "`title` should not be longer than 120 characters"
          )
        );
      }
      return value;
    }
  },
  description: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(
          ERROR_PREFIX.concat("`description` should be a string")
        );
      }
      if (typeof value === "string" && value.length > 155) {
        throw new Error(
          ERROR_PREFIX.concat(
            "`description` should not be longer than 155 characters"
          )
        );
      }
      return value;
    }
  },
  url: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(ERROR_PREFIX.concat("`url` should be a string"));
      }
      if (typeof value === "string" && !value.startsWith("http")) {
        throw new Error(ERROR_PREFIX.concat("`url` should be a valid URL"));
      }
      return value;
    }
  },
  handle: {
    validate: (value) => {
      if (typeof value !== "string") {
        throw new Error(ERROR_PREFIX.concat("`handle` should be a string"));
      }
      if (typeof value === "string" && !value.startsWith("@")) {
        throw new Error(ERROR_PREFIX.concat("`handle` should start with `@`"));
      }
      return value;
    }
  }
};
function generateSeoTags(seoInput) {
  const tagResults = [];
  for (const seoKey of Object.keys(seoInput)) {
    switch (seoKey) {
      case "title": {
        const content = validate(schema.title, seoInput.title);
        const title = renderTitle(seoInput?.titleTemplate, content);
        if (!title) {
          break;
        }
        tagResults.push(
          generateTag("title", { title }),
          generateTag("meta", { property: "og:title", content: title }),
          generateTag("meta", { name: "twitter:title", content: title })
        );
        break;
      }
      case "description": {
        const content = validate(schema.description, seoInput.description);
        if (!content) {
          break;
        }
        tagResults.push(
          generateTag("meta", {
            name: "description",
            content
          }),
          generateTag("meta", {
            property: "og:description",
            content
          }),
          generateTag("meta", {
            name: "twitter:description",
            content
          })
        );
        break;
      }
      case "url": {
        const content = validate(schema.url, seoInput.url);
        if (!content) {
          break;
        }
        const urlWithoutParams = content.split("?")[0];
        tagResults.push(
          generateTag("link", {
            rel: "canonical",
            href: urlWithoutParams
          }),
          generateTag("meta", {
            property: "og:url",
            content: urlWithoutParams
          })
        );
        break;
      }
      case "handle": {
        const content = validate(schema.handle, seoInput.handle);
        if (!content) {
          break;
        }
        tagResults.push(
          generateTag("meta", { name: "twitter:site", content }),
          generateTag("meta", { name: "twitter:creator", content })
        );
        break;
      }
      case "media": {
        let content;
        const values = ensureArray(seoInput.media);
        for (const media of values) {
          if (typeof media === "string") {
            tagResults.push(
              generateTag("meta", { name: "og:image", content: media })
            );
          }
          if (media && typeof media === "object") {
            const type = media.type || "image";
            const normalizedMedia = media ? {
              url: media?.url,
              secure_url: media?.url,
              type: inferMimeType(media.url),
              width: media?.width,
              height: media?.height,
              alt: media?.altText
            } : {};
            for (const key of Object.keys(normalizedMedia)) {
              if (normalizedMedia[key]) {
                content = normalizedMedia[key];
                tagResults.push(
                  generateTag(
                    "meta",
                    {
                      property: `og:${type}:${key}`,
                      content
                    },
                    normalizedMedia.url
                  )
                );
              }
            }
          }
        }
        break;
      }
      case "jsonLd": {
        const jsonLdBlocks = ensureArray(seoInput.jsonLd);
        let index = 0;
        for (const block of jsonLdBlocks) {
          if (typeof block !== "object") {
            continue;
          }
          const tag = generateTag(
            "script",
            {
              type: "application/ld+json",
              children: JSON.stringify(block)
            },
            // @ts-expect-error
            `json-ld-${block?.["@type"] || block?.name || index++}`
          );
          tagResults.push(tag);
        }
        break;
      }
      case "alternates": {
        const alternates = ensureArray(seoInput.alternates);
        for (const alternate of alternates) {
          if (!alternate) {
            continue;
          }
          const { language, url, default: defaultLang } = alternate;
          const hrefLang = language ? `${language}${defaultLang ? "-default" : ""}` : void 0;
          tagResults.push(
            generateTag("link", {
              rel: "alternate",
              hrefLang,
              href: url
            })
          );
        }
        break;
      }
      case "robots": {
        if (!seoInput.robots) {
          break;
        }
        const {
          maxImagePreview,
          maxSnippet,
          maxVideoPreview,
          noArchive,
          noFollow,
          noImageIndex,
          noIndex,
          noSnippet,
          noTranslate,
          unavailableAfter
        } = seoInput.robots;
        const robotsParams = [
          noArchive && "noarchive",
          noImageIndex && "noimageindex",
          noSnippet && "nosnippet",
          noTranslate && `notranslate`,
          maxImagePreview && `max-image-preview:${maxImagePreview}`,
          maxSnippet && `max-snippet:${maxSnippet}`,
          maxVideoPreview && `max-video-preview:${maxVideoPreview}`,
          unavailableAfter && `unavailable_after:${unavailableAfter}`
        ];
        let robotsParam = (noIndex ? "noindex" : "index") + "," + (noFollow ? "nofollow" : "follow");
        for (let param of robotsParams) {
          if (param) {
            robotsParam += `,${param}`;
          }
        }
        tagResults.push(
          generateTag("meta", { name: "robots", content: robotsParam })
        );
        break;
      }
    }
  }
  return tagResults.flat().sort((a, b) => a.key.localeCompare(b.key));
}
function generateTag(tagName, input, group) {
  const tag = { tag: tagName, props: {}, key: "" };
  if (tagName === "title") {
    tag.children = input.title;
    tag.key = generateKey(tag);
    return tag;
  }
  if (tagName === "script") {
    tag.children = typeof input.children === "string" ? input.children : "";
    tag.key = generateKey(tag, group);
    delete input.children;
    tag.props = input;
    return tag;
  }
  tag.props = input;
  Object.keys(tag.props).forEach(
    (key) => !tag.props[key] && delete tag.props[key]
  );
  tag.key = generateKey(tag, group);
  return tag;
}
function generateKey(tag, group) {
  const { tag: tagName, props } = tag;
  if (tagName === "title") {
    return "0-title";
  }
  if (tagName === "meta") {
    const priority = props.content === group && typeof props.property === "string" && !props.property.endsWith("secure_url") && "0";
    const groupName = [group, priority];
    return [tagName, ...groupName, props.property || props.name].filter((x) => x).join("-");
  }
  if (tagName === "link") {
    const key = [tagName, props.rel, props.hrefLang || props.media].filter((x) => x).join("-");
    return key.replace(/\s+/g, "-");
  }
  if (tagName === "script") {
    return `${tagName}-${group}`;
  }
  return `${tagName}-${props.type}`;
}
function renderTitle(template, title) {
  if (!title) {
    return void 0;
  }
  if (!template) {
    return title;
  }
  if (typeof template === "function") {
    return template(title);
  }
  return template.replace("%s", title ?? "");
}
function inferMimeType(url) {
  const ext = url && url.split(".").pop();
  switch (ext) {
    case "svg":
      return "image/svg+xml";
    case "png":
      return "image/png";
    case "gif":
      return "image/gif";
    case "swf":
      return "application/x-shockwave-flash";
    case "mp3":
      return "audio/mpeg";
    case "jpg":
    case "jpeg":
    default:
      return "image/jpeg";
  }
}
function ensureArray(value) {
  return Array.isArray(value) ? value : [value];
}
function validate(schema2, data) {
  try {
    return schema2.validate(data);
  } catch (error) {
    console.warn(error.message);
    return data;
  }
}

// src/seo/seo.ts
var SeoLogger = lazy(() => import('./log-seo-tags-IG37ONQ2.js'));
function Seo({ debug }) {
  const matches = useMatches();
  const location = useLocation();
  const seoConfig = useMemo(() => {
    return matches.flatMap((match) => {
      const { handle, ...routeMatch } = match;
      const routeData = { ...routeMatch, ...location };
      const handleSeo = handle?.seo;
      const loaderSeo = routeMatch?.data?.seo;
      if (!handleSeo && !loaderSeo) {
        return [];
      }
      if (handleSeo) {
        return recursivelyInvokeOrReturn(handleSeo, routeData);
      } else {
        return [loaderSeo];
      }
    }).reduce((acc, current) => {
      Object.keys(current).forEach(
        (key) => !current[key] && delete current[key]
      );
      const { jsonLd } = current;
      if (!jsonLd) {
        return { ...acc, ...current };
      }
      if (!acc?.jsonLd) {
        return { ...acc, ...current, jsonLd: [jsonLd] };
      } else {
        if (Array.isArray(jsonLd)) {
          return {
            ...acc,
            ...current,
            jsonLd: [...acc.jsonLd, ...jsonLd]
          };
        } else {
          return {
            ...acc,
            ...current,
            jsonLd: [...acc.jsonLd, jsonLd]
          };
        }
      }
    }, {});
  }, [matches, location]);
  const { html, loggerMarkup } = useMemo(() => {
    const headTags = generateSeoTags(seoConfig);
    const html2 = headTags.map((tag) => {
      if (tag.tag === "script") {
        return createElement(tag.tag, {
          ...tag.props,
          key: tag.key,
          dangerouslySetInnerHTML: { __html: tag.children }
        });
      }
      return createElement(tag.tag, { ...tag.props, key: tag.key }, tag.children);
    });
    const loggerMarkup2 = createElement(
      Suspense,
      { fallback: null },
      createElement(SeoLogger, { headTags })
    );
    return { html: html2, loggerMarkup: loggerMarkup2 };
  }, [seoConfig]);
  return createElement(Fragment, null, html, debug && loggerMarkup);
}
function recursivelyInvokeOrReturn(value, ...rest) {
  if (value instanceof Function) {
    return recursivelyInvokeOrReturn(value(...rest), ...rest);
  }
  let result = {};
  if (Array.isArray(value)) {
    result = value.reduce((acc, item) => {
      return [...acc, recursivelyInvokeOrReturn(item)];
    }, []);
    return result;
  }
  if (value instanceof Object) {
    const entries = Object.entries(value);
    entries.forEach(([key, val]) => {
      result[key] = recursivelyInvokeOrReturn(val, ...rest);
    });
    return result;
  }
  return value;
}
function Pagination({
  connection,
  children = () => {
    console.warn("<Pagination> requires children to work properly");
    return null;
  }
}) {
  const transition = useNavigation();
  const isLoading = transition.state === "loading";
  const {
    endCursor,
    hasNextPage,
    hasPreviousPage,
    nextPageUrl,
    nodes,
    previousPageUrl,
    startCursor
  } = usePagination(connection);
  const state = useMemo(
    () => ({
      pageInfo: {
        endCursor,
        hasPreviousPage,
        hasNextPage,
        startCursor
      },
      nodes
    }),
    [endCursor, hasNextPage, hasPreviousPage, startCursor, nodes]
  );
  const NextLink = useMemo(
    () => forwardRef(function NextLink2(props, ref) {
      return hasNextPage ? createElement(Link, {
        preventScrollReset: true,
        ...props,
        to: nextPageUrl,
        state,
        replace: true,
        ref
      }) : null;
    }),
    [hasNextPage, nextPageUrl, state]
  );
  const PreviousLink = useMemo(
    () => forwardRef(function PrevLink(props, ref) {
      return hasPreviousPage ? createElement(Link, {
        preventScrollReset: true,
        ...props,
        to: previousPageUrl,
        state,
        replace: true,
        ref
      }) : null;
    }),
    [hasPreviousPage, previousPageUrl, state]
  );
  return children({
    state,
    hasNextPage,
    hasPreviousPage,
    isLoading,
    nextPageUrl,
    nodes,
    previousPageUrl,
    NextLink,
    PreviousLink
  });
}
function getParamsWithoutPagination(paramsString) {
  const params = new URLSearchParams(paramsString);
  params.delete("cursor");
  params.delete("direction");
  return params.toString();
}
function makeError(prop) {
  throw new Error(
    `The Pagination component requires ${"`" + prop + "`"} to be a part of your query. See the guide on how to setup your query to include ${"`" + prop + "`"}: https://shopify.dev/docs/custom-storefronts/hydrogen/data-fetching/pagination#setup-the-paginated-query`
  );
}
function usePagination(connection) {
  if (!connection.pageInfo) {
    makeError("pageInfo");
  }
  if (typeof connection.pageInfo.startCursor === "undefined") {
    makeError("pageInfo.startCursor");
  }
  if (typeof connection.pageInfo.endCursor === "undefined") {
    makeError("pageInfo.endCursor");
  }
  if (typeof connection.pageInfo.hasNextPage === "undefined") {
    makeError("pageInfo.hasNextPage");
  }
  if (typeof connection.pageInfo.hasPreviousPage === "undefined") {
    makeError("pageInfo.hasPreviousPage");
  }
  const navigate = useNavigate();
  const { state, search, pathname } = useLocation();
  const params = new URLSearchParams(search);
  const direction = params.get("direction");
  const isPrevious = direction === "previous";
  const nodes = useMemo(() => {
    if (!globalThis?.window?.__hydrogenHydrated || !state || !state?.nodes) {
      return flattenConnection(connection);
    }
    if (isPrevious) {
      return [...flattenConnection(connection), ...state.nodes];
    } else {
      return [...state.nodes, ...flattenConnection(connection)];
    }
  }, [state, connection]);
  const currentPageInfo = useMemo(() => {
    const hydrogenHydrated = globalThis?.window?.__hydrogenHydrated;
    let pageStartCursor = !hydrogenHydrated || state?.pageInfo?.startCursor === void 0 ? connection.pageInfo.startCursor : state.pageInfo.startCursor;
    let pageEndCursor = !hydrogenHydrated || state?.pageInfo?.endCursor === void 0 ? connection.pageInfo.endCursor : state.pageInfo.endCursor;
    let previousPageExists = !hydrogenHydrated || state?.pageInfo?.hasPreviousPage === void 0 ? connection.pageInfo.hasPreviousPage : state.pageInfo.hasPreviousPage;
    let nextPageExists = !hydrogenHydrated || state?.pageInfo?.hasNextPage === void 0 ? connection.pageInfo.hasNextPage : state.pageInfo.hasNextPage;
    if (state?.nodes) {
      if (isPrevious) {
        pageStartCursor = connection.pageInfo.startCursor;
        previousPageExists = connection.pageInfo.hasPreviousPage;
      } else {
        pageEndCursor = connection.pageInfo.endCursor;
        nextPageExists = connection.pageInfo.hasNextPage;
      }
    }
    return {
      startCursor: pageStartCursor,
      endCursor: pageEndCursor,
      hasPreviousPage: previousPageExists,
      hasNextPage: nextPageExists
    };
  }, [
    isPrevious,
    state,
    connection.pageInfo.hasNextPage,
    connection.pageInfo.hasPreviousPage,
    connection.pageInfo.startCursor,
    connection.pageInfo.endCursor
  ]);
  const urlRef = useRef({
    params: getParamsWithoutPagination(search),
    pathname
  });
  useEffect(() => {
    window.__hydrogenHydrated = true;
  }, []);
  useEffect(() => {
    if (
      // If the URL changes (independent of pagination params)
      // then reset the pagination params in the URL
      getParamsWithoutPagination(search) !== urlRef.current.params || pathname !== urlRef.current.pathname
    ) {
      urlRef.current = {
        pathname,
        params: getParamsWithoutPagination(search)
      };
      navigate(`${pathname}?${getParamsWithoutPagination(search)}`, {
        replace: true,
        preventScrollReset: true,
        state: { nodes: void 0, pageInfo: void 0 }
      });
    }
  }, [pathname, search]);
  const previousPageUrl = useMemo(() => {
    const params2 = new URLSearchParams(search);
    params2.set("direction", "previous");
    currentPageInfo.startCursor && params2.set("cursor", currentPageInfo.startCursor);
    return `?${params2.toString()}`;
  }, [search, currentPageInfo.startCursor]);
  const nextPageUrl = useMemo(() => {
    const params2 = new URLSearchParams(search);
    params2.set("direction", "next");
    currentPageInfo.endCursor && params2.set("cursor", currentPageInfo.endCursor);
    return `?${params2.toString()}`;
  }, [search, currentPageInfo.endCursor]);
  return { ...currentPageInfo, previousPageUrl, nextPageUrl, nodes };
}
function getPaginationVariables(request, options = { pageBy: 20 }) {
  if (typeof request?.url === "undefined") {
    throw new Error(
      "getPaginationVariables must be called with the Request object passed to your loader function"
    );
  }
  const { pageBy } = options;
  const searchParams = new URLSearchParams(new URL(request.url).search);
  const cursor = searchParams.get("cursor") ?? void 0;
  const direction = searchParams.get("direction") === "previous" ? "previous" : "next";
  const isPrevious = direction === "previous";
  const prevPage = {
    last: pageBy,
    startCursor: cursor ?? null
  };
  const nextPage = {
    first: pageBy,
    endCursor: cursor ?? null
  };
  const variables = isPrevious ? prevPage : nextPage;
  return variables;
}

// src/customer/BadRequest.ts
var BadRequest = class extends Response {
  constructor(message, helpMessage) {
    if (helpMessage && true) {
      console.error("Customer Account API Error: " + helpMessage);
    }
    super(`Bad request: ${message}`, { status: 400 });
  }
};

// src/customer/auth.helpers.ts
var USER_AGENT = `Shopify Hydrogen ${LIB_VERSION}`;
var CUSTOMER_API_CLIENT_ID = "30243aa5-17c1-465a-8493-944bcc4e88aa";
function redirect2(path, options = {}) {
  const headers = options.headers ? new Headers(options.headers) : new Headers({});
  headers.set("location", path);
  return new Response(null, { status: options.status || 302, headers });
}
async function refreshToken({
  session,
  customerAccountId,
  customerAccountUrl,
  origin
}) {
  const newBody = new URLSearchParams();
  const refreshToken2 = session.get("refresh_token");
  if (!refreshToken2)
    throw new BadRequest(
      "Unauthorized",
      "No refresh_token in the session. Make sure your session is configured correctly and passed to `createCustomerClient`."
    );
  newBody.append("grant_type", "refresh_token");
  newBody.append("refresh_token", refreshToken2);
  newBody.append("client_id", customerAccountId);
  const headers = {
    "content-type": "application/x-www-form-urlencoded",
    "User-Agent": USER_AGENT,
    Origin: origin
  };
  const response = await fetch(`${customerAccountUrl}/auth/oauth/token`, {
    method: "POST",
    headers,
    body: newBody
  });
  if (!response.ok) {
    const text = await response.text();
    throw new Response(text, {
      status: response.status,
      headers: {
        "Content-Type": "text/html; charset=utf-8"
      }
    });
  }
  const { access_token, expires_in, id_token, refresh_token } = await response.json();
  session.set("customer_authorization_code_token", access_token);
  session.set(
    "expires_at",
    new Date((/* @__PURE__ */ new Date()).getTime() + (expires_in - 120) * 1e3).getTime() + ""
  );
  session.set("id_token", id_token);
  session.set("refresh_token", refresh_token);
  const customerAccessToken = await exchangeAccessToken(
    session,
    customerAccountId,
    customerAccountUrl,
    origin
  );
  session.set("customer_access_token", customerAccessToken);
}
function clearSession(session) {
  session.unset("code-verifier");
  session.unset("customer_authorization_code_token");
  session.unset("expires_at");
  session.unset("id_token");
  session.unset("refresh_token");
  session.unset("customer_access_token");
  session.unset("state");
  session.unset("nonce");
}
async function checkExpires({
  locks,
  expiresAt,
  session,
  customerAccountId,
  customerAccountUrl,
  origin
}) {
  if (parseInt(expiresAt, 10) - 1e3 < (/* @__PURE__ */ new Date()).getTime()) {
    try {
      if (!locks.refresh)
        locks.refresh = refreshToken({
          session,
          customerAccountId,
          customerAccountUrl,
          origin
        });
      await locks.refresh;
      delete locks.refresh;
    } catch (error) {
      clearSession(session);
      if (error && error.status !== 401) {
        throw error;
      } else {
        throw new BadRequest(
          "Unauthorized",
          "Login before querying the Customer Account API."
        );
      }
    }
  }
}
async function generateCodeVerifier() {
  const rando = generateRandomCode();
  return base64UrlEncode(rando);
}
async function generateCodeChallenge(codeVerifier) {
  const digestOp = await crypto.subtle.digest(
    { name: "SHA-256" },
    new TextEncoder().encode(codeVerifier)
  );
  const hash = convertBufferToString(digestOp);
  return base64UrlEncode(hash);
}
function generateRandomCode() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return String.fromCharCode.apply(null, Array.from(array));
}
function base64UrlEncode(str) {
  const base64 = btoa(str);
  return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function convertBufferToString(hash) {
  const uintArray = new Uint8Array(hash);
  const numberArray = Array.from(uintArray);
  return String.fromCharCode(...numberArray);
}
async function generateState() {
  const timestamp = Date.now().toString();
  const randomString = Math.random().toString(36).substring(2);
  return timestamp + randomString;
}
async function exchangeAccessToken(session, customerAccountId, customerAccountUrl, origin) {
  const clientId = customerAccountId;
  const accessToken = session.get("customer_authorization_code_token");
  if (!accessToken)
    throw new BadRequest(
      "Unauthorized",
      "No access token found in the session. Make sure your session is configured correctly and passed to `createCustomerClient`."
    );
  const body = new URLSearchParams();
  body.append("grant_type", "urn:ietf:params:oauth:grant-type:token-exchange");
  body.append("client_id", clientId);
  body.append("audience", CUSTOMER_API_CLIENT_ID);
  body.append("subject_token", accessToken);
  body.append(
    "subject_token_type",
    "urn:ietf:params:oauth:token-type:access_token"
  );
  body.append("scopes", "https://api.customers.com/auth/customer.graphql");
  const headers = {
    "content-type": "application/x-www-form-urlencoded",
    "User-Agent": USER_AGENT,
    Origin: origin
  };
  const response = await fetch(`${customerAccountUrl}/auth/oauth/token`, {
    method: "POST",
    headers,
    body
  });
  const data = await response.json();
  if (data.error) {
    throw new BadRequest(data.error_description);
  }
  return data.access_token;
}
function getNonce(token) {
  return decodeJwt(token).payload.nonce;
}
function decodeJwt(token) {
  const [header, payload, signature] = token.split(".");
  const decodedHeader = JSON.parse(atob(header));
  const decodedPayload = JSON.parse(atob(payload));
  return {
    header: decodedHeader,
    payload: decodedPayload,
    signature
  };
}

// src/csp/nonce.ts
function generateNonce() {
  return toHexString(randomUint8Array());
}
function randomUint8Array() {
  try {
    return crypto.getRandomValues(new Uint8Array(16));
  } catch (e) {
    return new Uint8Array(16).map(() => Math.random() * 255 | 0);
  }
}
function toHexString(byteArray) {
  return Array.from(byteArray, function(byte) {
    return ("0" + (byte & 255).toString(16)).slice(-2);
  }).join("");
}

// src/customer/customer.ts
var DEFAULT_CUSTOMER_API_VERSION = "2024-01";
function createCustomerClient({
  session,
  customerAccountId,
  customerAccountUrl,
  customerApiVersion = DEFAULT_CUSTOMER_API_VERSION,
  request,
  waitUntil
}) {
  if (customerApiVersion !== DEFAULT_CUSTOMER_API_VERSION) {
    console.log(
      `[h2:warn:createCustomerClient] You are using Customer Account API version ${customerApiVersion} when this version of Hydrogen was built for ${DEFAULT_CUSTOMER_API_VERSION}.`
    );
  }
  if (!request?.url) {
    throw new Error(
      "[h2:error:createCustomerClient] The request object does not contain a URL."
    );
  }
  const url = new URL(request.url);
  const origin = url.protocol === "http:" ? url.origin.replace("http", "https") : url.origin;
  const locks = {};
  const logSubRequestEvent = (query, startTime) => {
    globalThis.__H2O_LOG_EVENT?.({
      eventType: "subrequest",
      url: `https://shopify.dev/?${hashKey([
        `Customer Account `,
        /((query|mutation) [^\s\(]+)/g.exec(query)?.[0] || query.substring(0, 10)
      ])}`,
      startTime,
      waitUntil,
      ...getDebugHeaders(request)
    });
  } ;
  async function fetchCustomerAPI({
    query,
    type,
    variables = {}
  }) {
    const accessToken = session.get("customer_access_token");
    const expiresAt = session.get("expires_at");
    if (!accessToken || !expiresAt)
      throw new BadRequest(
        "Unauthorized",
        "Login before querying the Customer Account API."
      );
    await checkExpires({
      locks,
      expiresAt,
      session,
      customerAccountId,
      customerAccountUrl,
      origin
    });
    const startTime = (/* @__PURE__ */ new Date()).getTime();
    const response = await fetch(
      `${customerAccountUrl}/account/customer/api/${customerApiVersion}/graphql`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "User-Agent": USER_AGENT,
          Origin: origin,
          Authorization: accessToken
        },
        body: JSON.stringify({
          operationName: "SomeQuery",
          query,
          variables
        })
      }
    );
    logSubRequestEvent?.(query, startTime);
    const body = await response.text();
    const errorOptions = {
      response,
      type,
      query,
      queryVariables: variables,
      errors: void 0,
      client: "customer"
    };
    if (!response.ok) {
      let errors;
      try {
        errors = parseJSON(body);
      } catch (_e) {
        errors = [{ message: body }];
      }
      throwGraphQLError({ ...errorOptions, errors });
    }
    try {
      return parseJSON(body);
    } catch (e) {
      throwGraphQLError({ ...errorOptions, errors: [{ message: body }] });
    }
  }
  return {
    login: async () => {
      const loginUrl = new URL(customerAccountUrl + "/auth/oauth/authorize");
      const state = await generateState();
      const nonce = await generateNonce();
      loginUrl.searchParams.set("client_id", customerAccountId);
      loginUrl.searchParams.set("scope", "openid email");
      loginUrl.searchParams.append("response_type", "code");
      loginUrl.searchParams.append("redirect_uri", origin + "/authorize");
      loginUrl.searchParams.set(
        "scope",
        "openid email https://api.customers.com/auth/customer.graphql"
      );
      loginUrl.searchParams.append("state", state);
      loginUrl.searchParams.append("nonce", nonce);
      const verifier = await generateCodeVerifier();
      const challenge = await generateCodeChallenge(verifier);
      session.set("code-verifier", verifier);
      session.set("state", state);
      session.set("nonce", nonce);
      loginUrl.searchParams.append("code_challenge", challenge);
      loginUrl.searchParams.append("code_challenge_method", "S256");
      return redirect2(loginUrl.toString(), {
        headers: {
          "Set-Cookie": await session.commit()
        }
      });
    },
    logout: async () => {
      const idToken = session.get("id_token");
      clearSession(session);
      return redirect2(
        `${customerAccountUrl}/auth/logout?id_token_hint=${idToken}`,
        {
          status: 302,
          headers: {
            "Set-Cookie": await session.commit()
          }
        }
      );
    },
    isLoggedIn: async () => {
      const expiresAt = session.get("expires_at");
      if (!session.get("customer_access_token") || !expiresAt)
        return false;
      const startTime = (/* @__PURE__ */ new Date()).getTime();
      try {
        await checkExpires({
          locks,
          expiresAt,
          session,
          customerAccountId,
          customerAccountUrl,
          origin
        });
        logSubRequestEvent?.(" check expires", startTime);
      } catch {
        return false;
      }
      return true;
    },
    mutate(mutation, options) {
      mutation = minifyQuery(mutation);
      assertMutation(mutation, "customer.mutate");
      return fetchCustomerAPI({ query: mutation, type: "mutation", ...options });
    },
    query(query, options) {
      query = minifyQuery(query);
      assertQuery(query, "customer.query");
      return fetchCustomerAPI({ query, type: "query", ...options });
    },
    authorize: async (redirectPath = "/") => {
      const code = url.searchParams.get("code");
      const state = url.searchParams.get("state");
      if (!code || !state) {
        clearSession(session);
        throw new BadRequest(
          "Unauthorized",
          "No code or state parameter found in the redirect URL."
        );
      }
      if (session.get("state") !== state) {
        clearSession(session);
        throw new BadRequest(
          "Unauthorized",
          "The session state does not match the state parameter. Make sure that the session is configured correctly and passed to `createCustomerClient`."
        );
      }
      const clientId = customerAccountId;
      const body = new URLSearchParams();
      body.append("grant_type", "authorization_code");
      body.append("client_id", clientId);
      body.append("redirect_uri", origin + "/authorize");
      body.append("code", code);
      const codeVerifier = session.get("code-verifier");
      if (!codeVerifier)
        throw new BadRequest(
          "Unauthorized",
          "No code verifier found in the session. Make sure that the session is configured correctly and passed to `createCustomerClient`."
        );
      body.append("code_verifier", codeVerifier);
      const headers = {
        "content-type": "application/x-www-form-urlencoded",
        "User-Agent": USER_AGENT,
        Origin: origin
      };
      const response = await fetch(`${customerAccountUrl}/auth/oauth/token`, {
        method: "POST",
        headers,
        body
      });
      if (!response.ok) {
        throw new Response(await response.text(), {
          status: response.status,
          headers: {
            "Content-Type": "text/html; charset=utf-8"
          }
        });
      }
      const { access_token, expires_in, id_token, refresh_token } = await response.json();
      const sessionNonce = session.get("nonce");
      const responseNonce = await getNonce(id_token);
      if (sessionNonce !== responseNonce) {
        throw new BadRequest(
          "Unauthorized",
          `Returned nonce does not match: ${sessionNonce} !== ${responseNonce}`
        );
      }
      session.set("customer_authorization_code_token", access_token);
      session.set(
        "expires_at",
        new Date((/* @__PURE__ */ new Date()).getTime() + (expires_in - 120) * 1e3).getTime() + ""
      );
      session.set("id_token", id_token);
      session.set("refresh_token", refresh_token);
      const customerAccessToken = await exchangeAccessToken(
        session,
        customerAccountId,
        customerAccountUrl,
        origin
      );
      session.set("customer_access_token", customerAccessToken);
      return redirect2(redirectPath, {
        headers: {
          "Set-Cookie": await session.commit()
        }
      });
    }
  };
}

// src/changelogHandler.ts
var DEFAULT_GITHUB_CHANGELOG_URL = "https://raw.githubusercontent.com/Shopify/hydrogen/main/docs/changelog.json";
async function changelogHandler({
  request,
  changelogUrl
}) {
  new URL(request.url).searchParams;
  const GITHUB_CHANGELOG_URL = changelogUrl || DEFAULT_GITHUB_CHANGELOG_URL;
  return fetch(GITHUB_CHANGELOG_URL);
}
var INPUT_NAME = "cartFormInput";
function CartForm({
  children,
  action,
  inputs,
  route
}) {
  const fetcher = useFetcher();
  return /* @__PURE__ */ jsxs(fetcher.Form, { action: route || "", method: "post", children: [
    (action || inputs) && /* @__PURE__ */ jsx(
      "input",
      {
        type: "hidden",
        name: INPUT_NAME,
        value: JSON.stringify({ action, inputs })
      }
    ),
    typeof children === "function" ? children(fetcher) : children
  ] });
}
CartForm.INPUT_NAME = INPUT_NAME;
CartForm.ACTIONS = {
  AttributesUpdateInput: "AttributesUpdateInput",
  BuyerIdentityUpdate: "BuyerIdentityUpdate",
  Create: "Create",
  DiscountCodesUpdate: "DiscountCodesUpdate",
  LinesAdd: "LinesAdd",
  LinesRemove: "LinesRemove",
  LinesUpdate: "LinesUpdate",
  NoteUpdate: "NoteUpdate",
  SelectedDeliveryOptionsUpdate: "SelectedDeliveryOptionsUpdate",
  MetafieldsSet: "MetafieldsSet",
  MetafieldDelete: "MetafieldDelete"
};
function getFormInput(formData) {
  const data = {};
  for (const pair of formData.entries()) {
    const key = pair[0];
    const values = formData.getAll(key);
    data[key] = values.length > 1 ? values : pair[1];
  }
  const { cartFormInput, ...otherData } = data;
  const { action, inputs } = cartFormInput ? JSON.parse(String(cartFormInput)) : {};
  return {
    action,
    inputs: {
      ...inputs,
      ...otherData
    }
  };
}
CartForm.getFormInput = getFormInput;

// src/cart/queries/cart-fragments.ts
var USER_ERROR_FRAGMENT = `#graphql
  fragment CartApiError on CartUserError {
    message
    field
    code
  }
`;
var MINIMAL_CART_FRAGMENT = `#graphql
  fragment CartApiMutation on Cart {
    id
    totalQuantity
  }
`;

// src/cart/queries/cartCreateDefault.ts
function cartCreateDefault(options) {
  return async (input, optionalParams) => {
    const { cartId, ...restOfOptionalParams } = optionalParams || {};
    const { cartCreate } = await options.storefront.mutate(CART_CREATE_MUTATION(options.cartFragment), {
      variables: {
        input,
        ...restOfOptionalParams
      }
    });
    return cartCreate;
  };
}
var CART_CREATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartCreate(
    $input: CartInput!
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartCreate(input: $input) {
      cart {
        ...CartApiMutation
        checkoutUrl
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartGetDefault.ts
function cartGetDefault(options) {
  return async (cartInput) => {
    const cartId = options.getCartId();
    if (!cartId)
      return null;
    const { cart } = await options.storefront.query(
      CART_QUERY(options.cartFragment),
      {
        variables: {
          cartId,
          ...cartInput
        },
        cache: options.storefront.CacheNone()
      }
    );
    return cart;
  };
}
var CART_QUERY = (cartFragment = DEFAULT_CART_FRAGMENT) => `#graphql
  query CartQuery(
    $cartId: ID!
    $numCartLines: Int = 100
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cart(id: $cartId) {
      ...CartApiQuery
    }
  }

  ${cartFragment}
`;
var DEFAULT_CART_FRAGMENT = `#graphql
  fragment CartApiQuery on Cart {
    id
    checkoutUrl
    totalQuantity
    buyerIdentity {
      countryCode
      customer {
        id
        email
        firstName
        lastName
        displayName
      }
      email
      phone
    }
    lines(first: $numCartLines) {
      edges {
        node {
          id
          quantity
          attributes {
            key
            value
          }
          cost {
            totalAmount {
              amount
              currencyCode
            }
            amountPerQuantity {
              amount
              currencyCode
            }
            compareAtAmountPerQuantity {
              amount
              currencyCode
            }
          }
          merchandise {
            ... on ProductVariant {
              id
              availableForSale
              compareAtPrice {
                ...CartApiMoney
              }
              price {
                ...CartApiMoney
              }
              requiresShipping
              title
              image {
                ...CartApiImage
              }
              product {
                handle
                title
                id
              }
              selectedOptions {
                name
                value
              }
            }
          }
        }
      }
    }
    cost {
      subtotalAmount {
        ...CartApiMoney
      }
      totalAmount {
        ...CartApiMoney
      }
      totalDutyAmount {
        ...CartApiMoney
      }
      totalTaxAmount {
        ...CartApiMoney
      }
    }
    note
    attributes {
      key
      value
    }
    discountCodes {
      applicable
      code
    }
  }

  fragment CartApiMoney on MoneyV2 {
    currencyCode
    amount
  }

  fragment CartApiImage on Image {
    id
    url
    altText
    width
    height
  }
`;

// src/cart/queries/cartLinesAddDefault.ts
function cartLinesAddDefault(options) {
  return async (lines, optionalParams) => {
    const { cartLinesAdd } = await options.storefront.mutate(CART_LINES_ADD_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        lines,
        ...optionalParams
      }
    });
    return cartLinesAdd;
  };
}
var CART_LINES_ADD_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartLinesAdd(
    $cartId: ID!
    $lines: [CartLineInput!]!
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesAdd(cartId: $cartId, lines: $lines) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }

  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartLinesUpdateDefault.ts
function cartLinesUpdateDefault(options) {
  return async (lines, optionalParams) => {
    const { cartLinesUpdate } = await options.storefront.mutate(CART_LINES_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        lines,
        ...optionalParams
      }
    });
    return cartLinesUpdate;
  };
}
var CART_LINES_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartLinesUpdate(
    $cartId: ID!
    $lines: [CartLineUpdateInput!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartLinesUpdate(cartId: $cartId, lines: $lines) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }

  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartLinesRemoveDefault.ts
function cartLinesRemoveDefault(options) {
  return async (lineIds, optionalParams) => {
    const { cartLinesRemove } = await options.storefront.mutate(CART_LINES_REMOVE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        lineIds,
        ...optionalParams
      }
    });
    return cartLinesRemove;
  };
}
var CART_LINES_REMOVE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartLinesRemove(
    $cartId: ID!
    $lineIds: [ID!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartLinesRemove(cartId: $cartId, lineIds: $lineIds) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }

  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartDiscountCodesUpdateDefault.ts
function cartDiscountCodesUpdateDefault(options) {
  return async (discountCodes, optionalParams) => {
    const uniqueCodes = discountCodes.filter((value, index, array) => {
      return array.indexOf(value) === index;
    });
    const { cartDiscountCodesUpdate } = await options.storefront.mutate(CART_DISCOUNT_CODE_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        discountCodes: uniqueCodes,
        ...optionalParams
      }
    });
    return cartDiscountCodesUpdate;
  };
}
var CART_DISCOUNT_CODE_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartDiscountCodesUpdate(
    $cartId: ID!
    $discountCodes: [String!]
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartDiscountCodesUpdate(cartId: $cartId, discountCodes: $discountCodes) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartBuyerIdentityUpdateDefault.ts
function cartBuyerIdentityUpdateDefault(options) {
  return async (buyerIdentity, optionalParams) => {
    const { cartBuyerIdentityUpdate } = await options.storefront.mutate(CART_BUYER_IDENTITY_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        buyerIdentity,
        ...optionalParams
      }
    });
    return cartBuyerIdentityUpdate;
  };
}
var CART_BUYER_IDENTITY_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartBuyerIdentityUpdate(
    $cartId: ID!
    $buyerIdentity: CartBuyerIdentityInput!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartBuyerIdentityUpdate(cartId: $cartId, buyerIdentity: $buyerIdentity) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartNoteUpdateDefault.ts
function cartNoteUpdateDefault(options) {
  return async (note, optionalParams) => {
    const { cartNoteUpdate } = await options.storefront.mutate(CART_NOTE_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        note,
        ...optionalParams
      }
    });
    return cartNoteUpdate;
  };
}
var CART_NOTE_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartNoteUpdate(
    $cartId: ID!
    $note: String
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartNoteUpdate(cartId: $cartId, note: $note) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartSelectedDeliveryOptionsUpdateDefault.ts
function cartSelectedDeliveryOptionsUpdateDefault(options) {
  return async (selectedDeliveryOptions, optionalParams) => {
    const { cartSelectedDeliveryOptionsUpdate } = await options.storefront.mutate(CART_SELECTED_DELIVERY_OPTIONS_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: options.getCartId(),
        selectedDeliveryOptions,
        ...optionalParams
      }
    });
    return cartSelectedDeliveryOptionsUpdate;
  };
}
var CART_SELECTED_DELIVERY_OPTIONS_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartSelectedDeliveryOptionsUpdate(
    $cartId: ID!
    $selectedDeliveryOptions: [CartSelectedDeliveryOptionInput!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartSelectedDeliveryOptionsUpdate(cartId: $cartId, selectedDeliveryOptions: $selectedDeliveryOptions) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartAttributesUpdateDefault.ts
function cartAttributesUpdateDefault(options) {
  return async (attributes, optionalParams) => {
    const { cartAttributesUpdate } = await options.storefront.mutate(CART_ATTRIBUTES_UPDATE_MUTATION(options.cartFragment), {
      variables: {
        cartId: optionalParams?.cartId || options.getCartId(),
        attributes
      }
    });
    return cartAttributesUpdate;
  };
}
var CART_ATTRIBUTES_UPDATE_MUTATION = (cartFragment = MINIMAL_CART_FRAGMENT) => `#graphql
  mutation cartAttributesUpdate(
    $cartId: ID!
    $attributes: [AttributeInput!]!
  ) {
    cartAttributesUpdate(cartId: $cartId, attributes: $attributes) {
      cart {
        ...CartApiMutation
      }
      errors: userErrors {
        ...CartApiError
      }
    }
  }
  ${cartFragment}
  ${USER_ERROR_FRAGMENT}
`;

// src/cart/queries/cartMetafieldsSetDefault.ts
function cartMetafieldsSetDefault(options) {
  return async (metafields, optionalParams) => {
    const ownerId = optionalParams?.cartId || options.getCartId();
    const metafieldsWithOwnerId = metafields.map(
      (metafield) => ({
        ...metafield,
        ownerId
      })
    );
    const { cartMetafieldsSet } = await options.storefront.mutate(CART_METAFIELD_SET_MUTATION(), {
      variables: { metafields: metafieldsWithOwnerId }
    });
    return {
      cart: {
        id: ownerId
      },
      errors: cartMetafieldsSet.errors
    };
  };
}
var CART_METAFIELD_SET_MUTATION = () => `#graphql
  mutation cartMetafieldsSet(
    $metafields: [CartMetafieldsSetInput!]!
    $language: LanguageCode
    $country: CountryCode
  ) @inContext(country: $country, language: $language) {
    cartMetafieldsSet(metafields: $metafields) {
      errors: userErrors {
        code
        elementIndex
        field
        message
      }
    }
  }
`;

// src/cart/queries/cartMetafieldDeleteDefault.ts
function cartMetafieldDeleteDefault(options) {
  return async (key, optionalParams) => {
    const ownerId = optionalParams?.cartId || options.getCartId();
    const { cartMetafieldDelete } = await options.storefront.mutate(CART_METAFIELD_DELETE_MUTATION(), {
      variables: {
        input: {
          ownerId,
          key
        }
      }
    });
    return {
      cart: {
        id: ownerId
      },
      errors: cartMetafieldDelete.errors
    };
  };
}
var CART_METAFIELD_DELETE_MUTATION = () => `#graphql
  mutation cartMetafieldDelete(
    $input: CartMetafieldDeleteInput!
  ) {
    cartMetafieldDelete(input: $input) {
      errors: userErrors {
        code
        field
        message
      }
    }
  }
`;

// ../../node_modules/worktop/cookie/index.mjs
var g = /* @__PURE__ */ new Set([
  "domain",
  "path",
  "max-age",
  "expires",
  "samesite",
  "secure",
  "httponly"
]);
function u(a) {
  let r = {}, e, t, n = 0, m = a.split(/;\s*/g), s, i;
  for (; n < m.length; n++)
    if (t = m[n], e = t.indexOf("="), ~e) {
      if (s = t.substring(0, e++).trim(), i = t.substring(e).trim(), i[0] === '"' && (i = i.substring(1, i.length - 1)), ~i.indexOf("%"))
        try {
          i = decodeURIComponent(i);
        } catch (f) {
        }
      g.has(t = s.toLowerCase()) ? t === "expires" ? r.expires = new Date(i) : t === "max-age" ? r.maxage = +i : r[t] = i : r[s] = i;
    } else
      (s = t.trim().toLowerCase()) && (s === "httponly" || s === "secure") && (r[s] = true);
  return r;
}
function l(a, r, e = {}) {
  let t = a + "=" + encodeURIComponent(r);
  return e.expires && (t += "; Expires=" + new Date(e.expires).toUTCString()), e.maxage != null && e.maxage >= 0 && (t += "; Max-Age=" + (e.maxage | 0)), e.domain && (t += "; Domain=" + e.domain), e.path && (t += "; Path=" + e.path), e.samesite && (t += "; SameSite=" + e.samesite), (e.secure || e.samesite === "None") && (t += "; Secure"), e.httponly && (t += "; HttpOnly"), t;
}

// src/cart/cartGetIdDefault.ts
var cartGetIdDefault = (requestHeaders) => {
  const cookies = u(requestHeaders.get("Cookie") || "");
  return () => {
    return cookies.cart ? `gid://shopify/Cart/${cookies.cart}` : void 0;
  };
};

// src/cart/cartSetIdDefault.ts
var cartSetIdDefault = (cookieOptions) => {
  return (cartId) => {
    const headers = new Headers();
    headers.append(
      "Set-Cookie",
      l("cart", cartId.split("/").pop() || "", {
        path: "/",
        ...cookieOptions
      })
    );
    return headers;
  };
};

// src/cart/createCartHandler.ts
function createCartHandler(options) {
  const {
    getCartId,
    setCartId,
    storefront,
    cartQueryFragment,
    cartMutateFragment
  } = options;
  const mutateOptions = {
    storefront,
    getCartId,
    cartFragment: cartMutateFragment
  };
  const cartId = getCartId();
  const cartCreate = cartCreateDefault(mutateOptions);
  const methods = {
    get: cartGetDefault({
      storefront,
      getCartId,
      cartFragment: cartQueryFragment
    }),
    getCartId,
    setCartId,
    create: cartCreate,
    addLines: async (lines, optionalParams) => {
      return cartId || optionalParams?.cartId ? await cartLinesAddDefault(mutateOptions)(lines, optionalParams) : await cartCreate({ lines }, optionalParams);
    },
    updateLines: cartLinesUpdateDefault(mutateOptions),
    removeLines: cartLinesRemoveDefault(mutateOptions),
    updateDiscountCodes: async (discountCodes, optionalParams) => {
      return cartId || optionalParams?.cartId ? await cartDiscountCodesUpdateDefault(mutateOptions)(
        discountCodes,
        optionalParams
      ) : await cartCreate({ discountCodes }, optionalParams);
    },
    updateBuyerIdentity: async (buyerIdentity, optionalParams) => {
      return cartId || optionalParams?.cartId ? await cartBuyerIdentityUpdateDefault(mutateOptions)(
        buyerIdentity,
        optionalParams
      ) : await cartCreate({ buyerIdentity }, optionalParams);
    },
    updateNote: async (note, optionalParams) => {
      return cartId || optionalParams?.cartId ? await cartNoteUpdateDefault(mutateOptions)(note, optionalParams) : await cartCreate({ note }, optionalParams);
    },
    updateSelectedDeliveryOption: cartSelectedDeliveryOptionsUpdateDefault(mutateOptions),
    updateAttributes: async (attributes, optionalParams) => {
      return cartId || optionalParams?.cartId ? await cartAttributesUpdateDefault(mutateOptions)(
        attributes,
        optionalParams
      ) : await cartCreate({ attributes }, optionalParams);
    },
    setMetafields: async (metafields, optionalParams) => {
      return cartId || optionalParams?.cartId ? await cartMetafieldsSetDefault(mutateOptions)(
        metafields,
        optionalParams
      ) : await cartCreate({ metafields }, optionalParams);
    },
    deleteMetafield: cartMetafieldDeleteDefault(mutateOptions)
  };
  if ("customMethods" in options) {
    return {
      ...methods,
      ...options.customMethods ?? {}
    };
  } else {
    return methods;
  }
}
function VariantSelector({
  handle,
  options = [],
  variants: _variants = [],
  productPath = "products",
  children
}) {
  const variants = _variants instanceof Array ? _variants : flattenConnection(_variants);
  const { searchParams, path, alreadyOnProductPage } = useVariantPath(
    handle,
    productPath
  );
  const optionsWithOnlyOneValue = options.filter(
    (option) => option?.values?.length === 1
  );
  return createElement(
    Fragment,
    null,
    ...useMemo(() => {
      return options.filter((option) => option?.values?.length > 1).map((option) => {
        let activeValue;
        let availableValues = [];
        for (let value of option.values) {
          const clonedSearchParams = new URLSearchParams(
            alreadyOnProductPage ? searchParams : void 0
          );
          clonedSearchParams.set(option.name, value);
          optionsWithOnlyOneValue.forEach((option2) => {
            clonedSearchParams.set(option2.name, option2.values[0]);
          });
          const variant = variants.find(
            (variant2) => variant2?.selectedOptions?.every(
              (selectedOption) => clonedSearchParams.get(selectedOption?.name) === selectedOption?.value
            )
          );
          const currentParam = searchParams.get(option.name);
          const calculatedActiveValue = currentParam ? (
            // If a URL parameter exists for the current option, check if it equals the current value
            currentParam === value
          ) : false;
          if (calculatedActiveValue) {
            activeValue = value;
          }
          const searchString = "?" + clonedSearchParams.toString();
          availableValues.push({
            value,
            isAvailable: variant ? variant.availableForSale : true,
            to: path + searchString,
            search: searchString,
            isActive: calculatedActiveValue
          });
        }
        return children({
          option: {
            name: option.name,
            value: activeValue,
            values: availableValues
          }
        });
      });
    }, [options, variants, children])
  );
}
var getSelectedProductOptions = (request) => {
  if (typeof request?.url === "undefined")
    throw new TypeError(`Expected a Request instance, got ${typeof request}`);
  const searchParams = new URL(request.url).searchParams;
  const selectedOptions = [];
  searchParams.forEach((value, name) => {
    selectedOptions.push({ name, value });
  });
  return selectedOptions;
};
function useVariantPath(handle, productPath) {
  const { pathname, search } = useLocation();
  return useMemo(() => {
    const match = /(\/[a-zA-Z]{2}-[a-zA-Z]{2}\/)/g.exec(pathname);
    const isLocalePathname = match && match.length > 0;
    productPath = productPath.startsWith("/") ? productPath.substring(1) : productPath;
    const path = isLocalePathname ? `${match[0]}${productPath}/${handle}` : `/${productPath}/${handle}`;
    const searchParams = new URLSearchParams(search);
    return {
      searchParams,
      // If the current pathname matches the product page, we need to make sure
      // that we append to the current search params. Otherwise all the search
      // params can be generated new.
      alreadyOnProductPage: path === pathname,
      path
    };
  }, [pathname, search, handle, productPath]);
}
var NonceContext = createContext(void 0);
var NonceProvider = NonceContext.Provider;
var useNonce = () => useContext(NonceContext);
function createContentSecurityPolicy(directives = {}) {
  const nonce = generateNonce();
  const header = createCSPHeader(nonce, directives);
  const Provider = ({ children }) => {
    return createElement(NonceProvider, { value: nonce }, children);
  };
  return {
    nonce,
    header,
    NonceProvider: Provider
  };
}
function createCSPHeader(nonce, directives = {}) {
  const nonceString = `'nonce-${nonce}'`;
  const styleSrc = ["'self'", "'unsafe-inline'", "https://cdn.shopify.com"];
  const connectSrc = ["'self'", "https://monorail-edge.shopifysvc.com"];
  const defaultSrc = [
    "'self'",
    nonceString,
    "https://cdn.shopify.com",
    // Used for the Customer Account API
    "https://shopify.com"
  ];
  const defaultDirectives = {
    baseUri: ["'self'"],
    defaultSrc,
    frameAncestors: ["none"],
    styleSrc,
    connectSrc
  };
  {
    defaultDirectives.styleSrc = [...styleSrc, "localhost:*"];
    defaultDirectives.defaultSrc = [...defaultSrc, "localhost:*"];
    defaultDirectives.connectSrc = [
      ...connectSrc,
      "localhost:*",
      // For HMR:
      "ws://localhost:*",
      "ws://127.0.0.1:*"
    ];
  }
  const combinedDirectives = Object.assign({}, defaultDirectives, directives);
  if (combinedDirectives.scriptSrc instanceof Array && !combinedDirectives.scriptSrc.includes(nonceString)) {
    combinedDirectives.scriptSrc.push(nonceString);
  } else if (combinedDirectives.defaultSrc instanceof Array && !combinedDirectives.defaultSrc.includes(nonceString)) {
    combinedDirectives.defaultSrc.push(nonceString);
  }
  return cspBuilder({
    directives: combinedDirectives
  });
}
var Script = forwardRef(
  (props, ref) => {
    const nonce = useNonce();
    return /* @__PURE__ */ jsx("script", { suppressHydrationWarning: true, ...props, nonce, ref });
  }
);
function useOptimisticData(identifier) {
  const fetchers = useFetchers();
  const data = {};
  for (const { formData } of fetchers) {
    if (formData?.get("optimistic-identifier") === identifier) {
      try {
        if (formData.has("optimistic-data")) {
          const dataInForm = JSON.parse(
            String(formData.get("optimistic-data"))
          );
          Object.assign(data, dataInForm);
        }
      } catch {
      }
    }
  }
  return data;
}
function OptimisticInput({ id, data }) {
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx("input", { type: "hidden", name: "optimistic-identifier", value: id }),
    /* @__PURE__ */ jsx(
      "input",
      {
        type: "hidden",
        name: "optimistic-data",
        value: JSON.stringify(data)
      }
    )
  ] });
}
function ShopPayButton(props) {
  return /* @__PURE__ */ jsx(ShopPayButton$1, { channel: "hydrogen", ...props });
}
//! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartCreate
//! @see https://shopify.dev/docs/api/storefront/latest/queries/cart
//! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartLinesAdd
//! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartLinesUpdate
//! @see: https://shopify.dev/docs/api/storefront/latest/mutations/cartLinesRemove
//! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartDiscountCodesUpdate
//! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartBuyerIdentityUpdate
//! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartNoteUpdate
//! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartSelectedDeliveryOptionsUpdate
//! @see https://shopify.dev/docs/api/storefront/latest/mutations/cartMetafieldsSet
//! @see https://shopify.dev/docs/api/storefront/2023-10/mutations/cartMetafieldDelete

export { CacheCustom, CacheLong, CacheNone, CacheShort, CartForm, InMemoryCache, OptimisticInput, Pagination, Script, Seo, ShopPayButton, StorefrontApiError, VariantSelector, cartAttributesUpdateDefault, cartBuyerIdentityUpdateDefault, cartCreateDefault, cartDiscountCodesUpdateDefault, cartGetDefault, cartGetIdDefault, cartLinesAddDefault, cartLinesRemoveDefault, cartLinesUpdateDefault, cartMetafieldDeleteDefault, cartMetafieldsSetDefault, cartNoteUpdateDefault, cartSelectedDeliveryOptionsUpdateDefault, cartSetIdDefault, changelogHandler, createCartHandler, createContentSecurityPolicy, createCustomerClient as createCustomerClient__unstable, createStorefrontClient, createWithCache, generateCacheControlHeader, getPaginationVariables, getSelectedProductOptions, graphiqlLoader, isStorefrontApiError, storefrontRedirect, useNonce, useOptimisticData };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map