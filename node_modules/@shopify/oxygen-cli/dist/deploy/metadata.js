import { ciPlatform } from '@shopify/cli-kit/node/context/local';
import { getLatestGitCommit } from '@shopify/cli-kit/node/git';
import { outputWarn } from '@shopify/cli-kit/node/output';
import { maxLabelLength } from '../utils/utils.js';

async function getMetadata(config, logger) {
  const ciInfo = ciPlatform();
  let metadata = {};
  try {
    const gitCommit = await getLatestGitCommit(config.rootPath);
    const branch = (/HEAD -> ([^,]*)/.exec(gitCommit.refs) || [])[1];
    metadata = {
      actor: gitCommit.author_name,
      branch,
      commitDate: gitCommit.date,
      commitSha: gitCommit.hash,
      commitMessage: createCommitTitle(gitCommit.message)
    };
  } catch (error) {
    outputWarn(
      "Could not retrieve Git history, commit message will be unavailable.",
      logger
    );
  }
  if (ciInfo.isCI && ciInfo.name !== "unknown") {
    metadata = {
      ...metadata,
      ...ciInfo.metadata
    };
  }
  return {
    name: ciInfo.isCI ? ciInfo.name : "none",
    ...metadata,
    actor: config.metadata.user ?? metadata.actor,
    commitMessage: config.metadata.description ?? metadata.commitMessage,
    commitSha: config.metadata.version ?? metadata.commitSha,
    url: config.metadata.url ?? metadata.url
  };
}
function createCommitTitle(commitMessage) {
  const title = commitMessage.split("\n")[0]?.trim() || "";
  if (title.length <= maxLabelLength)
    return title;
  const lastSpaceIndex = title.lastIndexOf(" ", maxLabelLength - 3);
  return `${title.substring(
    0,
    lastSpaceIndex > -1 ? lastSpaceIndex : maxLabelLength - 3
  )}...`;
}
function getEnvironmentInput(config, metadata) {
  const tag = config.environmentTag || metadata.branch;
  return tag ? { tag } : void 0;
}
function createLabels(metadata) {
  const labels = [];
  const checkLabel = (labelKey, labelValue) => {
    const jsonString = JSON.stringify(labelValue);
    if (jsonString.length > maxLabelLength) {
      throw new Error(
        `Provided ${labelKey} metadata exceeds maximum length (max ${maxLabelLength} characters).`
      );
    }
    const label = `${labelKey}=${jsonString}`;
    labels.push(label);
  };
  if (metadata.name !== "unknown") {
    const keyMapping2 = {
      attempt: "attempt",
      run: "runId"
    };
    for (const [key, value] of Object.entries(keyMapping2)) {
      const metadataKey = key;
      if (metadata[metadataKey]) {
        labels.push(
          `${metadata.name}-${value}=${JSON.stringify(metadata[metadataKey])}`
        );
      }
    }
  }
  const keyMapping = {
    actor: "user",
    branch: "branch",
    commitDate: "commit-date",
    commitMessage: "description",
    commitSha: "version",
    url: "url"
  };
  for (const [key, value] of Object.entries(keyMapping)) {
    const metadataKey = key;
    if (metadata[metadataKey]) {
      checkLabel(value, metadata[metadataKey]);
    }
  }
  return labels;
}

export { createLabels, getEnvironmentInput, getMetadata };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=metadata.js.map