import { Agent } from 'https';
import { formData, fetch } from '@shopify/cli-kit/node/http';
import { createFileReadStream } from '@shopify/cli-kit/node/fs';
import { outputInfo, outputCompleted } from '@shopify/cli-kit/node/output';
import { joinPath } from '@shopify/cli-kit/node/path';
import { mapLimit } from 'async';
import { deployDefaults } from '../utils/utils.js';
import { MetricName } from '../utils/metrics-exporter.js';

async function uploadFiles(options) {
  const { config, logger, targets, hooks } = options;
  outputInfo(`Uploading ${targets.length} files...`, logger);
  const totalUploadSize = targets.reduce((total, target) => total + target.fileSize, 0) / 1024;
  options.metricsExporter?.add(MetricName.TotalSizeUploaded, totalUploadSize);
  options.metricsExporter?.add(MetricName.NumFilesUploaded, targets.length);
  const agent = new Agent({ keepAlive: true });
  hooks?.onUploadFilesStart?.();
  const startTime = performance.now();
  return mapLimit(targets, 6, async (target) => {
    await uploadFile(config, target, agent);
  }).then(() => {
    const endTime = performance.now();
    hooks?.onUploadFilesComplete?.();
    options.metricsExporter?.add(MetricName.UploadTime, endTime - startTime);
    outputCompleted(`Files uploaded successfully`, logger);
  }).catch((err) => {
    hooks?.onUploadFilesError?.(err);
    throw err;
  }).finally(() => {
    agent.destroy();
  });
}
async function uploadFile(config, target, agent) {
  const localFolderPath = target.fileType === "WORKER" ? joinPath(config.rootPath, config.workerDir) : joinPath(config.rootPath, config.assetsDir);
  if (target.parameters !== null && target.parameters.length > 0) {
    const form = formData();
    target.parameters.forEach((param) => {
      form.append(param.name, param.value);
    });
    form.append(
      "file",
      createFileReadStream(joinPath(localFolderPath, target.filePath))
    );
    await formUpload(form, target, agent);
  } else {
    const initData = await initiateResumableUpload(target, agent);
    await performResumableUpload(
      joinPath(localFolderPath, target.filePath),
      initData,
      agent
    );
  }
}
async function formUpload(form, target, agent, attemptNumber = 0) {
  try {
    const timeoutDuration = 12e4;
    const controller = new AbortController();
    const timeout = setTimeout(() => {
      controller.abort();
    }, timeoutDuration);
    const response = await fetch(target.uploadUrl, {
      method: "POST",
      body: form,
      signal: controller.signal,
      headers: {
        Connection: "keep-alive"
      },
      agent
    });
    clearTimeout(timeout);
    if (!response.ok) {
      throw new Error(`${response.status}`);
    }
  } catch (err) {
    if (isErrorCode(err, "ENOENT")) {
      throw new Error(`File not found: ${target.filePath}`);
    }
    if (attemptNumber < Number(deployDefaults.maxUploadAttempts)) {
      await formUpload(form, target, agent, attemptNumber + 1);
    } else {
      if (err instanceof Error && err.name === "AbortError") {
        throw new Error(`Request timeout whilst uploading ${target.filePath}`);
      }
      throw new Error(`Failed to upload file ${target.filePath}`);
    }
  }
}
async function initiateResumableUpload(target, agent) {
  return fetch(target.uploadUrl, {
    method: "POST",
    headers: {
      "x-goog-resumable": "start",
      "X-Goog-Content-Length-Range": `0,${target.fileSize}`,
      "User-Agent": "oxygen-cli"
    },
    agent
  }).then((res) => {
    return {
      sessionUri: res.headers.get("x-guploader-uploadid"),
      location: res.headers.get("location"),
      target
    };
  }).catch((err) => {
    throw new Error(
      `Failed to initiate resumable upload for file ${target.filePath} (status code ${err.statusCode})`
    );
  });
}
async function performResumableUpload(localFilePath, initData, agent, startByte = 0, attemptNumber = 0) {
  await uploadResumable(
    initData.location,
    localFilePath,
    startByte,
    agent
  ).catch(async (err) => {
    if (isErrorCode(err, "ENOENT")) {
      throw new Error(`File not found: ${initData.target.filePath}`);
    }
    if (err && attemptNumber >= Number(deployDefaults.maxResumabeUploadAttempts)) {
      throw new Error(
        `Failed to upload file ${initData.target.filePath} after ${deployDefaults.maxResumabeUploadAttempts} attempts`
      );
    }
    const status = await resumableUploadStatus(
      initData.location,
      initData.target.fileSize,
      agent
    );
    if (!status.complete) {
      const nextAttemptStartByte = status.lastReceivedByte;
      const attempt = attemptNumber + 1;
      await performResumableUpload(
        localFilePath,
        initData,
        agent,
        nextAttemptStartByte,
        attempt
      );
    }
  });
}
async function uploadResumable(location, filePath, lastReceivedByte, agent) {
  const file = createFileReadStream(filePath, { start: lastReceivedByte });
  return fetch(location, {
    method: "PUT",
    body: file,
    agent
  }).then((res) => {
    return res.status;
  });
}
async function resumableUploadStatus(location, fileSize, agent) {
  const getLastByte = (range) => {
    if (!range || range.split("-").length !== 2)
      return 0;
    const rangeParts = range.split("-");
    return parseInt(rangeParts[1], 10);
  };
  return fetch(location, {
    method: "PUT",
    headers: {
      "Content-Length": "0",
      "Content-Range": `bytes */${fileSize}`
    },
    agent
  }).then((res) => {
    return {
      complete: res.status === 200,
      lastReceivedByte: getLastByte(res.headers.get("range"))
    };
  }).catch((err) => {
    console.error(err);
    return {
      complete: false,
      lastReceivedByte: 0
    };
  });
}
function isErrorCode(err, code) {
  return err instanceof Error && "code" in err && err.code === code;
}

export { uploadFiles };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=upload-files.js.map