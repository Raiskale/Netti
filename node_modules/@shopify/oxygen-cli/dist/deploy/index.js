import { outputSuccess, outputInfo, outputWarn } from '@shopify/cli-kit/node/output';
import { stderrLogger, verifyConfig } from '../utils/utils.js';
export { parseToken } from '../utils/utils.js';
import { initializeBugsnag, getBugsnag } from '../utils/bugsnag.js';
import { MetricsExporter, MetricName } from '../utils/metrics-exporter.js';
import { buildInitiate } from './build-initiate.js';
import { buildCancel } from './build-cancel.js';
import { getUploadFiles } from './get-upload-files.js';
import { deploymentInitiate } from './deployment-initiate.js';
import { deploymentComplete } from './deployment-complete.js';
import { verifyDeployment } from './verify-deployment.js';
import { deploymentCancel } from './deployment-cancel.js';
import { uploadFiles } from './upload-files.js';
import { VerificationError } from './types.js';
import { buildProject } from './build-project.js';
import { getMetadata, createLabels, getEnvironmentInput } from './metadata.js';

async function createDeploy(options) {
  const cliStartTime = performance.now();
  initializeBugsnag(!options.config.bugsnag);
  const Bugsnag = getBugsnag();
  Bugsnag?.addMetadata("config", {
    ...options.config,
    deploymentToken: { ...options.config.deploymentToken, accessToken: "***" }
  });
  const { config, hooks } = options;
  const logger = options.logger ?? stderrLogger;
  const build = {};
  let buildCompleted;
  let deployment;
  try {
    const metadata = await getMetadata(config, logger);
    const labels = createLabels(metadata);
    const environment = getEnvironmentInput(config, metadata);
    Bugsnag?.addMetadata("metadata", {
      environment,
      labels,
      metadata
    });
    const metricsExporter = new MetricsExporter({
      ciProvider: metadata.name || "unknown",
      rootPath: config.rootPath
    });
    if (!config.workerOnly && !config.skipBuild) {
      const buildInitiateResponse = await buildInitiate({
        config,
        environment,
        labels,
        logger
      });
      build.id = buildInitiateResponse.build.id;
      build.assetPath = buildInitiateResponse.build.assetPath;
    }
    if (!config.skipBuild) {
      await buildProject({
        config,
        assetPath: build.assetPath,
        hooks,
        metricsExporter
      });
      await verifyConfig({ config, performedBuild: true });
    }
    buildCompleted = true;
    const manifest = await getUploadFiles(config, metricsExporter);
    Bugsnag?.addMetadata("manifest", manifest);
    const deploymentInitiateInput = build.id ? { buildId: build.id, manifest } : { environment, manifest, labels };
    deployment = await deploymentInitiate({
      config,
      input: deploymentInitiateInput,
      logger
    });
    await uploadFiles({
      config,
      targets: deployment.deploymentTargets,
      hooks,
      logger,
      metricsExporter
    });
    const deploymentCompleteOp = await deploymentComplete(
      config,
      deployment.deployment.id
    );
    metricsExporter.add(MetricName.TotalTime, performance.now() - cliStartTime);
    await metricsExporter.export();
    if (!config.skipVerification) {
      await verifyDeployment({
        config,
        url: deploymentCompleteOp.deployment.url,
        logger,
        hooks
      });
    }
    const urlMessage = config.publicDeployment ? "public" : "private";
    outputSuccess(
      `
The deployment can be reached at the ${deploymentCompleteOp.deployment.url} ${urlMessage} preview URL`,
      logger
    );
    if (metadata.name !== "none") {
      outputInfo(deploymentCompleteOp.deployment.url);
    }
    return deploymentCompleteOp.deployment.url;
  } catch (error) {
    if (config.bugsnag && Bugsnag && (error instanceof Error || typeof error === "string")) {
      Bugsnag.notify(error);
    }
    if (!(error instanceof Error)) {
      console.error("Unknown error", error);
      return Promise.reject(new Error("Unknown error"));
    }
    if (error instanceof VerificationError) {
      outputWarn(error.message, logger);
    } else if (build.id && !buildCompleted) {
      outputWarn(
        `Build failed with: ${error.message}, cancelling build.`,
        logger
      );
      await buildCancel({
        config,
        buildId: build.id,
        reason: error.message,
        logger
      }).catch((err) => {
        if (err instanceof Error) {
          outputWarn(`Failed to cancel build: ${err.message}`, logger);
        }
      });
    } else if (deployment?.deployment.id) {
      outputWarn(
        `Deployment failed with: ${error.message}, cancelling deployment.`,
        logger
      );
      await deploymentCancel({
        config,
        deploymentId: deployment.deployment.id,
        reason: error.message,
        logger
      }).catch((err) => {
        if (err instanceof Error) {
          outputWarn(`Failed to cancel deployment: ${err.message}`, logger);
        }
      });
    }
    return Promise.reject(error);
  }
}

export { createDeploy };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map