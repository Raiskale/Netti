import { EventEmitter } from 'node:events';
import { ReadableStream } from 'node:stream/web';
import { getGraphiQLUrl } from './graphiql-url.js';
import { Response } from '@shopify/mini-oxygen';

const H2O_BINDING_NAME = "H2O_LOG_EVENT";
let ResponseConstructor = Response;
function setConstructors(constructors) {
  ResponseConstructor = constructors.Response;
}
const DEV_ROUTES = /* @__PURE__ */ new Set(["/graphiql", "/debug-network"]);
const EVENT_MAP = {
  request: "Request",
  subrequest: "Sub request"
};
async function getRequestInfo(request) {
  const data = await request.json();
  return {
    id: data.requestId ?? "",
    eventType: data.eventType || "unknown",
    startTime: data.startTime,
    endTime: data.endTime || Date.now(),
    purpose: data.purpose === "prefetch" ? "(prefetch)" : "",
    cacheStatus: data.cacheStatus ?? "",
    graphql: data.graphql ? JSON.parse(data.graphql) : null
  };
}
const eventEmitter = new EventEmitter();
const eventHistory = [];
function createResponse(main = "ok", init) {
  return new ResponseConstructor(main, init);
}
async function clearHistory(request) {
  eventHistory.length = 0;
  return createResponse();
}
async function logRequestEvent(request) {
  const url = new URL(request.url);
  if (DEV_ROUTES.has(url.pathname)) {
    return createResponse();
  }
  const { eventType, purpose, graphql, ...data } = await getRequestInfo(request);
  let graphiqlLink = "";
  let description = request.url;
  if (eventType === "subrequest") {
    description = graphql?.query.match(/(query|mutation)\s+(\w+)/)?.[0]?.replace(/\s+/, " ") || decodeURIComponent(url.search.slice(1));
    if (graphql) {
      graphiqlLink = getGraphiQLUrl({ graphql });
    }
  }
  const event = {
    event: EVENT_MAP[eventType] || eventType,
    data: JSON.stringify({
      ...data,
      url: `${purpose} ${description}`.trim(),
      graphiqlLink
    })
  };
  eventHistory.push(event);
  if (eventHistory.length > 100)
    eventHistory.shift();
  eventEmitter.emit("request", event);
  return createResponse();
}
function streamRequestEvents(request) {
  const stream = new ReadableStream({
    start(controller) {
      const encoder = new TextEncoder();
      const enqueueEvent = ({ event = "message", data }) => {
        controller.enqueue(encoder.encode(`event: ${event}
`));
        controller.enqueue(encoder.encode(`data: ${data}

`));
      };
      eventHistory.forEach(enqueueEvent);
      eventEmitter.addListener("request", enqueueEvent);
      let closed = false;
      function close() {
        if (closed)
          return;
        closed = true;
        request.signal.removeEventListener("abort", close);
        eventEmitter.removeListener("request", enqueueEvent);
        controller.close();
      }
      request.signal.addEventListener("abort", close);
      if (request.signal.aborted)
        return close();
    }
  });
  return createResponse(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-store",
      Connection: "keep-alive"
    }
  });
}
function handleDebugNetworkRequest(request) {
  return request.method === "DELETE" ? clearHistory() : streamRequestEvents(request);
}

export { DEV_ROUTES, H2O_BINDING_NAME, handleDebugNetworkRequest, logRequestEvent, setConstructors };
