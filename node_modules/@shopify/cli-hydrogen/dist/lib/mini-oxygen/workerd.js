import crypto from 'node:crypto';
import { Response, Miniflare, fetch, Request, NoOpLog } from 'miniflare';
import { resolvePath, dirname } from '@shopify/cli-kit/node/path';
import { readFile } from '@shopify/cli-kit/node/fs';
import { renderSuccess } from '@shopify/cli-kit/node/ui';
import { createInspectorConnector } from './workerd-inspector.js';
import { findPort } from '../find-port.js';
import { OXYGEN_HEADERS_MAP, logRequestLine } from './common.js';
import { setConstructors, handleDebugNetworkRequest, H2O_BINDING_NAME, logRequestEvent } from '../request-events.js';
import { STATIC_ASSET_EXTENSIONS, createAssetsServer, buildAssetsUrl } from './assets.js';

const PRIVATE_WORKERD_INSPECTOR_PORT = 9222;
async function startWorkerdServer({
  root,
  port: appPort,
  inspectorPort: publicInspectorPort,
  assetsPort,
  debug = false,
  watch = false,
  buildPathWorkerFile,
  buildPathClient,
  env
}) {
  const privateInspectorPort = await findPort(PRIVATE_WORKERD_INSPECTOR_PORT);
  const oxygenHeadersMap = Object.values(OXYGEN_HEADERS_MAP).reduce(
    (acc, item) => {
      acc[item.name] = item.defaultValue;
      return acc;
    },
    {}
  );
  setConstructors({ Response });
  const absoluteBundlePath = resolvePath(root, buildPathWorkerFile);
  const handleAssets = createAssetHandler(assetsPort);
  const staticAssetExtensions = STATIC_ASSET_EXTENSIONS.slice();
  const buildMiniOxygenOptions = async () => ({
    cf: false,
    verbose: false,
    port: appPort,
    inspectorPort: privateInspectorPort,
    log: new NoOpLog(),
    liveReload: watch,
    host: "localhost",
    workers: [
      {
        name: "mini-oxygen",
        modules: true,
        script: `export default { fetch: ${miniOxygenHandler.toString()} }`,
        bindings: {
          staticAssetExtensions,
          oxygenHeadersMap
        },
        serviceBindings: {
          hydrogen: "hydrogen",
          assets: handleAssets,
          debugNetwork: handleDebugNetworkRequest,
          logRequest
        }
      },
      {
        name: "hydrogen",
        modulesRoot: dirname(absoluteBundlePath),
        modules: [
          {
            type: "ESModule",
            path: absoluteBundlePath,
            contents: await readFile(absoluteBundlePath)
          }
        ],
        compatibilityFlags: ["streams_enable_constructors"],
        compatibilityDate: "2022-10-31",
        bindings: { ...env },
        serviceBindings: {
          [H2O_BINDING_NAME]: logRequestEvent
        }
      }
    ]
  });
  let miniOxygenOptions = await buildMiniOxygenOptions();
  const miniOxygen = new Miniflare(miniOxygenOptions);
  const listeningAt = (await miniOxygen.ready).origin;
  const sourceMapPath = buildPathWorkerFile + ".map";
  const reconnect = createInspectorConnector({
    debug,
    sourceMapPath,
    absoluteBundlePath,
    privateInspectorPort,
    publicInspectorPort
  });
  await reconnect();
  const assetsServer = createAssetsServer(buildPathClient);
  assetsServer.listen(assetsPort);
  return {
    port: appPort,
    listeningAt,
    async reload(nextOptions) {
      miniOxygenOptions = await buildMiniOxygenOptions();
      if (nextOptions) {
        const hydrogen = miniOxygenOptions.workers.find(
          (worker) => worker.name === "hydrogen"
        );
        if (hydrogen) {
          hydrogen.bindings = { ...nextOptions?.env ?? env };
        }
      }
      await reconnect(() => miniOxygen.setOptions(miniOxygenOptions));
    },
    showBanner(options) {
      console.log("");
      const debuggerMessage = `

Debug mode enabled. Attach a ${process.env.TERM_PROGRAM === "vscode" ? "VSCode " : ""}debugger to port ${publicInspectorPort}
or open DevTools in http://localhost:${publicInspectorPort}`;
      renderSuccess({
        headline: `${options?.headlinePrefix ?? ""}MiniOxygen (Worker Runtime) ${options?.mode ?? "development"} server running.`,
        body: [
          `View ${options?.appName ?? "Hydrogen"} app: ${listeningAt}`,
          ...options?.extraLines ?? [],
          ...debug ? [{ warn: debuggerMessage }] : []
        ]
      });
      console.log("");
    },
    async close() {
      assetsServer.closeAllConnections();
      assetsServer.close();
      await miniOxygen.dispose();
    }
  };
}
async function miniOxygenHandler(request, env, context) {
  const { pathname } = new URL(request.url);
  if (pathname === "/debug-network-server") {
    return env.debugNetwork.fetch(request);
  }
  if (request.method === "GET") {
    const staticAssetExtensions = new Set(env.staticAssetExtensions);
    const wellKnown = pathname.startsWith("/.well-known");
    const extension = pathname.split(".").at(-1) ?? "";
    const isAsset = wellKnown || !!staticAssetExtensions.has(extension.toUpperCase());
    if (isAsset) {
      const response2 = await env.assets.fetch(
        new Request(request.url, {
          signal: request.signal,
          headers: request.headers
        })
      );
      if (response2.status !== 404)
        return response2;
    }
  }
  const requestInit = {
    headers: {
      "request-id": crypto.randomUUID(),
      ...env.oxygenHeadersMap,
      ...Object.fromEntries(request.headers.entries())
    }
  };
  const startTimeMs = Date.now();
  const response = await env.hydrogen.fetch(request, requestInit);
  const durationMs = Date.now() - startTimeMs;
  context.waitUntil(
    env.logRequest.fetch(
      new Request(request.url, {
        method: request.method,
        signal: request.signal,
        headers: {
          ...requestInit.headers,
          "h2-duration-ms": String(durationMs),
          "h2-response-status": String(response.status)
        }
      })
    )
  );
  return response;
}
function createAssetHandler(assetsPort) {
  const assetsServerOrigin = buildAssetsUrl(assetsPort);
  return async (request) => {
    return fetch(
      new Request(
        request.url.replace(new URL(request.url).origin, assetsServerOrigin),
        request
      )
    );
  };
}
async function logRequest(request) {
  logRequestLine(request, {
    responseStatus: Number(request.headers.get("h2-response-status") || 200),
    durationMs: Number(request.headers.get("h2-duration-ms") || 0)
  });
  return new Response("ok");
}

export { startWorkerdServer };
