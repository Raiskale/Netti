import { renderFatalError, renderWarning, renderInfo } from '@shopify/cli-kit/node/ui';
import { BugError } from '@shopify/cli-kit/node/error';
import { outputContent, outputToken } from '@shopify/cli-kit/node/output';
import colors from '@shopify/cli-kit/node/colors';
import { getGraphiQLUrl } from './graphiql-url.js';

const originalConsole = { ...console };
const methodsReplaced = /* @__PURE__ */ new Set();
const addedReplacers = /* @__PURE__ */ new Set();
const messageReplacers = [];
function resetAllLogs() {
  Object.assign(console, originalConsole);
  methodsReplaced.clear();
}
function addMessageReplacers(key, ...items) {
  if (!addedReplacers.has(key)) {
    addedReplacers.add(key);
    messageReplacers.push(...items);
  }
}
const printedMessages = /* @__PURE__ */ new Set();
function debounceMessage(args, debounceFor) {
  const key = args.map((item) => {
    const message = item?.message ?? item;
    return typeof message === "string" ? message : "";
  }).filter(Boolean).join("");
  if (printedMessages.has(key))
    return true;
  printedMessages.add(key);
  if (debounceFor !== true) {
    setTimeout(() => printedMessages.delete(key), debounceFor ?? 1e3);
  }
  return false;
}
function injectLogReplacer(method, debouncer) {
  if (!methodsReplaced.has(method)) {
    methodsReplaced.add(method);
    console[method] = (...args) => {
      if (debounceMessage(args, debouncer?.(args)))
        return;
      const replacers = messageReplacers.reduce((acc, [matcher, replacer]) => {
        if (matcher(args))
          acc.push(replacer);
        return acc;
      }, []);
      if (replacers.length === 0)
        return originalConsole[method](...args);
      const result = replacers.reduce(
        (resultArgs, replacer) => resultArgs && replacer(resultArgs),
        args
      );
      if (result)
        return originalConsole[method](...result);
    };
  }
}
function muteDevLogs({ workerReload } = {}) {
  injectLogReplacer("log");
  injectLogReplacer("error");
  injectLogReplacer("warn");
  let isFirstWorkerReload = true;
  addMessageReplacers("dev-node", [
    ([first]) => typeof first === "string" && first.includes("[mf:"),
    (args) => {
      const first = args[0];
      if (workerReload !== false && first.includes("Worker reloaded")) {
        if (isFirstWorkerReload) {
          isFirstWorkerReload = false;
          return;
        }
        return [first.replace("[mf:inf] ", "\u{1F504} ") + "\n", ...args.slice(1)];
      }
      if (!first.includes("[mf:err]")) {
        return;
      }
    }
  ]);
  addMessageReplacers(
    "dev-workerd",
    [
      // Workerd logs
      ([first]) => typeof first === "string" && /^\x1B\[31m(workerd\/|stack:)/.test(first),
      () => {
      }
    ],
    // Non-actionable warnings/errors:
    [
      ([first]) => typeof first === "string" && /^A promise rejection/i.test(first),
      () => {
      }
    ],
    [
      ([first]) => {
        const message = first?.message ?? first;
        return typeof message === "string" && /^Network connection lost/i.test(message);
      },
      () => {
      }
    ]
  );
}
const originalWrite = process.stdout.write;
function muteAuthLogs({
  onPressKey,
  onKeyTimeout
}) {
  if (process.stdout.write === originalWrite) {
    const write = originalWrite.bind(process.stdout);
    process.stdout.write = (item, cb) => {
      if (typeof item !== "string")
        return write(item, cb);
      const replacers = messageReplacers.reduce((acc, [matcher, replacer]) => {
        if (matcher([item]))
          acc.push(replacer);
        return acc;
      }, []);
      if (replacers.length === 0)
        return write(item, cb);
      const result = replacers.reduce(
        (resultArgs, replacer) => resultArgs && replacer(resultArgs),
        [item]
      );
      if (result)
        return write(result[0], cb);
    };
  }
  addMessageReplacers(
    "auth",
    [
      ([first]) => typeof first === "string" && first.includes("Auto-open"),
      ([first]) => {
        const content = first.replace(" to Shopify Partners", "");
        const link = content.match(/(https?:\/\/.*)Log in/)?.[1];
        onKeyTimeout(link);
        if (link)
          return;
        return [content];
      }
    ],
    [
      ([first]) => typeof first === "string" && first.includes("\u{1F449}"),
      () => {
        onPressKey();
        return;
      }
    ],
    [
      ([first]) => typeof first === "string" && (first.includes("Shopify Partners") || first.includes("Logged in")),
      () => {
        return;
      }
    ]
  );
  return () => {
    process.stdout.write = originalWrite;
  };
}
function enhanceH2Logs(options) {
  injectLogReplacer("error");
  injectLogReplacer(
    "warn",
    ([first]) => (
      // Show createStorefrontClient warnings only once.
      first?.includes?.("[h2:warn:createStorefrontClient]") ? true : void 0
    )
  );
  addMessageReplacers("h2-warn", [
    ([first]) => {
      const message = first?.message ?? first;
      return typeof message === "string" && message.includes("[h2:");
    },
    (args) => {
      const firstArg = args[0];
      const errorObject = typeof firstArg === "object" && !!firstArg.stack ? firstArg : void 0;
      const stringArg = errorObject?.message ?? firstArg;
      const [, type, scope, message] = stringArg.match(/\[h2:([^:]+):([^\]]+)\]\s+(.*)$/ims) || [];
      if (!type || !scope || !message)
        return args;
      const headline = `In Hydrogen's \`${scope.trim()}\`:

`;
      const lines = message.split("\n");
      const lastLine = lines.at(-1) ?? "";
      const hasLinks = /https?:\/\//.test(lastLine);
      if (hasLinks)
        lines.pop();
      if (type === "error" || errorObject) {
        let tryMessage = hasLinks ? lastLine : void 0;
        let stack = errorObject?.stack;
        let cause = errorObject?.cause;
        if (typeof cause === "string") {
          try {
            cause = JSON.parse(cause);
          } catch {
          }
        }
        if (typeof cause !== "string" && !!cause?.graphql?.query) {
          const link = getGraphiQLUrl({
            host: options.host,
            graphql: cause.graphql
          });
          const [, queryType, queryName] = cause.graphql.query.match(/(query|mutation)\s+(\w+)/) || [];
          tryMessage = (tryMessage ? `${tryMessage}

` : "") + outputContent`To debug the ${queryType || "query"}${queryName ? ` \`${colors.whiteBright(queryName)}\`` : ""}, try it in ${outputToken.link(colors.bold("GraphiQL"), link)}.`.value;
        }
        const stackLines = stack?.split("\n") ?? [];
        const isAppLine = (line) => line.includes(options.rootDirectory) && !line.includes("node_modules");
        const firstAppLineIndex = stackLines.findIndex(isAppLine);
        const lastAppLineIndex = stackLines.length - [...stackLines].reverse().findIndex(isAppLine);
        if (firstAppLineIndex > 0 && lastAppLineIndex > firstAppLineIndex) {
          stack = [
            stackLines[0],
            // Error message
            ...stackLines.slice(firstAppLineIndex, lastAppLineIndex)
            // App code
          ].join("\n").trim() || void 0;
        }
        const error = new BugError(
          headline + colors.bold(lines.join("\n").replace(" - Request", "\nRequest")),
          tryMessage
        );
        error.cause = cause;
        error.stack = stack;
        renderFatalError(error);
        return;
      }
      let reference = void 0;
      if (hasLinks) {
        reference = [];
        for (const link of lastLine.matchAll(/https?:\/\/[^\s]+/g)) {
          reference.push(link[0]);
        }
      }
      const render = type === "warn" ? renderWarning : renderInfo;
      render({
        body: headline + colors.bold(lines.join("\n")),
        reference
      });
      return;
    }
  ]);
}
const warnings = /* @__PURE__ */ new Set();
const warnOnce = (string) => {
  if (!warnings.has(string)) {
    console.warn(string);
    warnings.add(string);
  }
};
function createRemixLogger() {
  const noop = () => {
  };
  const buildMessageBody = (message, details) => `In Remix:

` + colors.bold(message) + (details ? "\n\n" + details.join("\n") : "");
  return {
    dev: noop,
    info: noop,
    debug: noop,
    warn: (message, options) => {
      renderWarning({ body: buildMessageBody(message, options?.details) });
    },
    error: (message, options) => {
      renderFatalError({
        name: "error",
        type: 0,
        message: buildMessageBody(message, options?.details),
        skipOclifErrorHandling: true,
        tryMessage: ""
      });
    }
  };
}
async function muteRemixLogs() {
  try {
    const { logger } = await import('@remix-run/dev/dist/tux/logger.js');
    logger.warn = logger.debug = logger.info = () => {
    };
  } catch {
  }
}

export { addMessageReplacers, createRemixLogger, enhanceH2Logs, muteAuthLogs, muteDevLogs, muteRemixLogs, resetAllLogs, warnOnce };
