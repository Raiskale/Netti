import path from 'path';
import fs from 'fs/promises';
import { outputInfo, outputDebug } from '@shopify/cli-kit/node/output';
import { fileExists } from '@shopify/cli-kit/node/fs';
import { renderFatalError } from '@shopify/cli-kit/node/ui';
import colors from '@shopify/cli-kit/node/colors';
import { copyPublicFiles } from './build.js';
import { getProjectPaths, assertOxygenChecks, handleRemixImportFail, getRemixConfig } from '../../lib/remix-config.js';
import { muteDevLogs, createRemixLogger, enhanceH2Logs } from '../../lib/log.js';
import { commonFlags, overrideFlag, deprecated, flagsToCamelObject } from '../../lib/flags.js';
import Command from '@shopify/cli-kit/node/base-command';
import { Flags } from '@oclif/core';
import { buildAssetsUrl, startMiniOxygen } from '../../lib/mini-oxygen/index.js';
import { addVirtualRoutes } from '../../lib/virtual-routes.js';
import { spawnCodegenProcess } from '../../lib/codegen.js';
import { getAllEnvironmentVariables } from '../../lib/environment-variables.js';
import { getConfig } from '../../lib/shopify-config.js';
import { setupLiveReload } from '../../lib/live-reload.js';
import { checkRemixVersions } from '../../lib/remix-version-check.js';
import { getGraphiQLUrl } from '../../lib/graphiql-url.js';
import { displayDevUpgradeNotice } from './upgrade.js';
import { findPort } from '../../lib/find-port.js';

const LOG_REBUILDING = "\u{1F9F1} Rebuilding...";
const LOG_REBUILT = "\u{1F680} Rebuilt";
class Dev extends Command {
  static description = "Runs Hydrogen storefront in an Oxygen worker for development.";
  static flags = {
    path: commonFlags.path,
    port: commonFlags.port,
    worker: commonFlags.workerRuntime,
    codegen: overrideFlag(commonFlags.codegen, {
      description: commonFlags.codegen.description + " It updates the types on file save."
    }),
    "codegen-config-path": commonFlags.codegenConfigPath,
    sourcemap: commonFlags.sourcemap,
    "disable-virtual-routes": Flags.boolean({
      description: "Disable rendering fallback routes when a route file doesn't exist.",
      env: "SHOPIFY_HYDROGEN_FLAG_DISABLE_VIRTUAL_ROUTES",
      default: false
    }),
    debug: commonFlags.debug,
    "inspector-port": commonFlags.inspectorPort,
    host: deprecated("--host")(),
    ["env-branch"]: commonFlags.envBranch,
    ["disable-version-check"]: Flags.boolean({
      description: "Skip the version check when running `hydrogen dev`",
      default: false,
      required: false
    })
  };
  async run() {
    const { flags } = await this.parse(Dev);
    const directory = flags.path ? path.resolve(flags.path) : process.cwd();
    await runDev({
      ...flagsToCamelObject(flags),
      path: directory
    });
  }
}
async function runDev({
  port: appPort,
  path: appPath,
  codegen: useCodegen = false,
  worker: workerRuntime = false,
  codegenConfigPath,
  disableVirtualRoutes,
  envBranch,
  debug = false,
  sourcemap = true,
  disableVersionCheck = false,
  inspectorPort
}) {
  if (!process.env.NODE_ENV)
    process.env.NODE_ENV = "development";
  muteDevLogs();
  const { root, publicPath, buildPathClient, buildPathWorkerFile } = getProjectPaths(appPath);
  const copyingFiles = copyPublicFiles(publicPath, buildPathClient);
  const reloadConfig = async () => {
    const config = await getRemixConfig(root);
    return disableVirtualRoutes ? config : addVirtualRoutes(config).catch((error) => {
      outputDebug(
        "Could not add virtual routes: " + (error?.stack ?? error?.message ?? error)
      );
      return config;
    });
  };
  const getFilePaths = (file) => {
    const fileRelative = path.relative(root, file);
    return [fileRelative, path.resolve(root, fileRelative)];
  };
  const serverBundleExists = () => fileExists(buildPathWorkerFile);
  inspectorPort = debug ? await findPort(inspectorPort) : inspectorPort;
  appPort = workerRuntime ? await findPort(appPort) : appPort;
  const assetsPort = workerRuntime ? await findPort(appPort + 100) : 0;
  if (assetsPort) {
    process.env.HYDROGEN_ASSET_BASE_URL = buildAssetsUrl(assetsPort);
  }
  const [remixConfig, { shop, storefront }] = await Promise.all([
    reloadConfig(),
    getConfig(root)
  ]);
  assertOxygenChecks(remixConfig);
  const fetchRemote = !!shop && !!storefront?.id;
  const envPromise = getAllEnvironmentVariables({ root, fetchRemote, envBranch });
  const [{ watch }, { createFileWatchCache }] = await Promise.all([
    import('@remix-run/dev/dist/compiler/watch.js'),
    import('@remix-run/dev/dist/compiler/fileWatchCache.js')
  ]).catch(handleRemixImportFail);
  let isInitialBuild = true;
  let initialBuildDurationMs = 0;
  let initialBuildStartTimeMs = Date.now();
  const liveReload = await setupLiveReload(remixConfig.dev?.port ?? 8002) ;
  let miniOxygen;
  async function safeStartMiniOxygen() {
    if (miniOxygen)
      return;
    miniOxygen = await startMiniOxygen(
      {
        root,
        debug,
        assetsPort,
        inspectorPort,
        port: appPort,
        watch: !liveReload,
        buildPathWorkerFile,
        buildPathClient,
        env: await envPromise
      },
      workerRuntime
    );
    enhanceH2Logs({ host: miniOxygen.listeningAt, ...remixConfig });
    miniOxygen.showBanner({
      appName: storefront ? colors.cyan(storefront?.title) : void 0,
      headlinePrefix: initialBuildDurationMs > 0 ? `Initial build: ${initialBuildDurationMs}ms
` : "",
      extraLines: [
        colors.dim(
          `
View GraphiQL API browser: ${getGraphiQLUrl({
            host: miniOxygen.listeningAt
          })}`
        ),
        colors.dim(
          `
View server-side network requests: ${miniOxygen.listeningAt}/debug-network`
        )
      ]
    });
    if (useCodegen) {
      spawnCodegenProcess({ ...remixConfig, configFilePath: codegenConfigPath });
    }
    checkRemixVersions();
    if (!disableVersionCheck) {
      displayDevUpgradeNotice({ targetPath: appPath });
    }
  }
  const fileWatchCache = createFileWatchCache();
  let skipRebuildLogs = false;
  await watch(
    {
      config: remixConfig,
      options: {
        mode: process.env.NODE_ENV,
        sourcemap
      },
      fileWatchCache,
      logger: createRemixLogger()
    },
    {
      reloadConfig,
      onBuildStart(ctx) {
        if (!isInitialBuild && !skipRebuildLogs) {
          outputInfo(LOG_REBUILDING);
          console.time(LOG_REBUILT);
        }
        liveReload?.onBuildStart(ctx);
      },
      onBuildManifest: liveReload?.onBuildManifest,
      async onBuildFinish(context, duration, succeeded) {
        if (isInitialBuild) {
          await copyingFiles;
          initialBuildDurationMs = Date.now() - initialBuildStartTimeMs;
          isInitialBuild = false;
        } else if (!skipRebuildLogs) {
          skipRebuildLogs = false;
          console.timeEnd(LOG_REBUILT);
          if (!miniOxygen)
            console.log("");
        }
        if (!miniOxygen && !await serverBundleExists()) {
          return renderFatalError({
            name: "BuildError",
            type: 0,
            message: "MiniOxygen cannot start because the server bundle has not been generated.",
            skipOclifErrorHandling: true,
            tryMessage: "This is likely due to an error in your app and Remix is unable to compile. Try fixing the app and MiniOxygen will start."
          });
        }
        if (succeeded) {
          if (!miniOxygen) {
            await safeStartMiniOxygen();
          } else if (liveReload) {
            await miniOxygen.reload();
          }
          liveReload?.onAppReady(context);
        }
      },
      async onFileCreated(file) {
        const [relative, absolute] = getFilePaths(file);
        outputInfo(`
\u{1F4C4} File created: ${relative}`);
        if (absolute.startsWith(publicPath)) {
          await copyPublicFiles(
            absolute,
            absolute.replace(publicPath, buildPathClient)
          );
        }
      },
      async onFileChanged(file) {
        fileWatchCache.invalidateFile(file);
        const [relative, absolute] = getFilePaths(file);
        outputInfo(`
\u{1F4C4} File changed: ${relative}`);
        if (relative.endsWith(".env")) {
          skipRebuildLogs = true;
          await miniOxygen.reload({
            env: await getAllEnvironmentVariables({
              root,
              fetchRemote,
              envBranch
            })
          });
        }
        if (absolute.startsWith(publicPath)) {
          await copyPublicFiles(
            absolute,
            absolute.replace(publicPath, buildPathClient)
          );
        }
      },
      async onFileDeleted(file) {
        fileWatchCache.invalidateFile(file);
        const [relative, absolute] = getFilePaths(file);
        outputInfo(`
\u{1F4C4} File deleted: ${relative}`);
        if (absolute.startsWith(publicPath)) {
          await fs.unlink(absolute.replace(publicPath, buildPathClient));
        }
      }
    }
  );
}

export { Dev as default };
